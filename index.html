<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>就喜欢你看不惯我，又干不掉我的样子~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="就喜欢你看不惯我，又干不掉我的样子~">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="就喜欢你看不惯我，又干不掉我的样子~">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="就喜欢你看不惯我，又干不掉我的样子~">
  
    <link rel="alternate" href="/atom.xml" title="就喜欢你看不惯我，又干不掉我的样子~" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">就喜欢你看不惯我，又干不掉我的样子~</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-LeetCode134" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/18/LeetCode134/" class="article-date">
  <time datetime="2017-12-18T03:16:54.000Z" itemprop="datePublished">2017-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/18/LeetCode134/">LeetCode134. Gas Station</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/gas-station/description/" target="_blank" rel="external">Description</a></h1><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br>The solution is guaranteed to be unique.</p>
<h2 id="Demo-用了一个数学定理"><a href="#Demo-用了一个数学定理" class="headerlink" title="Demo(用了一个数学定理)"></a>Demo(用了一个数学定理)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123;</div><div class="line">  int start = 0; // 起始位置</div><div class="line">  int remain = 0; // 当前剩余燃料</div><div class="line">  int debt = 0; // 前面没能走完的路上欠的债</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (int i = 0; i &lt; gas.size(); i++) &#123;</div><div class="line">    remain += gas[i] - cost[i];</div><div class="line">    <span class="keyword">if</span> (remain &lt; 0) &#123;</div><div class="line">      debt += remain;</div><div class="line">      start = i + 1;</div><div class="line">      remain = 0;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">return</span> remain + debt &gt;= 0 ? start : -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//思路：<br>非常经典的一道题。可以转换成求最大连续和做，但是有更简单的方法。基于一个数学定理：</p>
<p>如果一个数组的总和非负，那么一定可以找到一个起始位置，从他开始绕数组一圈，累加和一直都是非负的<br>有了这个定理，判断到底是否存在这样的解非常容易，只需要把全部的油耗情况计算出来看看是否大于等于0即可。</p>
<p>那么如何求开始位置在哪？</p>
<p>注意到这样一个现象：</p>
<ol>
<li>假如从位置i开始，i+1，i+2…，一路开过来一路油箱都没有空。说明什么？说明从i到i+1，i+2，…肯定是正积累。</li>
<li>现在突然发现开往位置j时油箱空了。这说明什么？说明从位置i开始没法走完全程(废话)。那么，我们要从位置i+1开始重新尝试吗？<br>不需要！为什么？因为前面已经知道，位置i肯定是正积累，那么，如果从位置i+1开始走更加没法走完全程了，因为没有位置i的正积累了。<br>同理，也不用从i+2，i+3，…开始尝试。所以我们可以放心地从位置j+1开始尝试。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/18/LeetCode134/" data-id="cjbbmvx7r0003vwnlvi9fiqwm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/贪心法/">贪心法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode137" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/17/LeetCode137/" class="article-date">
  <time datetime="2017-12-17T09:00:24.000Z" itemprop="datePublished">2017-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/LeetCode137/">LeetCode137. Single Number II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/single-number-ii/description/" target="_blank" rel="external">Description</a></h1><p>Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<h2 id="Demo-按位与或"><a href="#Demo-按位与或" class="headerlink" title="Demo(按位与或)"></a>Demo(按位与或)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int length=nums.size();</div><div class="line">        int result=0;</div><div class="line">        <span class="keyword">for</span>(int i=0;i&lt;32;i++)</div><div class="line">        &#123;</div><div class="line">            int count=0;</div><div class="line">            int mask=1&lt;&lt;i;//设置某一位为一，方便后面的按位与或操作</div><div class="line">            <span class="keyword">for</span>(int j=0;j&lt;length;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums[j]&amp;mask)</div><div class="line">                    count++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(count%3)</div><div class="line">                result|=mask;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>考虑每个元素的为一个32位的二进制数，这样每一位上出现要么为1，要么为0。对数组，统计每一位上1 出现的次数count，必定是3N或者3N+1 次。让count对3取模，能够获得到那个只出现1次的元素该位是0还是1。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/17/LeetCode137/" data-id="cjbbmvx6w0000vwnloopj2rzp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/复杂度/">复杂度</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode138" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/17/LeetCode138/" class="article-date">
  <time datetime="2017-12-17T03:41:08.000Z" itemprop="datePublished">2017-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/17/LeetCode138/">LeetCode138. Copy List with Random Pointer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="external">Description</a></h1><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="Demo1-使用hash-map"><a href="#Demo1-使用hash-map" class="headerlink" title="Demo1(使用hash_map)"></a>Demo1(使用hash_map)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list with a random pointer.</div><div class="line"> * struct RandomListNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     RandomListNode *next, *random;</div><div class="line"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</div><div class="line">        <span class="keyword">if</span> (!head) <span class="built_in">return</span> NULL;</div><div class="line">        unordered_map&lt;RandomListNode*, RandomListNode*&gt; mp;</div><div class="line">        // 创建一个新的链表头</div><div class="line">        RandomListNode *new_head = new RandomListNode(head-&gt;label);</div><div class="line">        // node1负责指向原链表，node2负责指向新链表</div><div class="line">        RandomListNode *node1 = head, *node2 = new_head;</div><div class="line">        /**</div><div class="line">         * 按照原链表的结构不断创建新的节点，并维护好next指针，将node1与node2的对应关系保存到hash_map中，</div><div class="line">         * 以备后面维护random指针的时候，可以通过node1找到对应的node2。</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span> (node1-&gt;next != NULL) &#123;</div><div class="line">            mp[node1] = node2;</div><div class="line">            node1 = node1-&gt;next;</div><div class="line">            node2-&gt;next = new RandomListNode(node1-&gt;label);</div><div class="line">            node2 = node2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        // 将两个链表的尾巴的对应关系也保存好</div><div class="line">        mp[node1] = node2;</div><div class="line">        </div><div class="line">        // 继续从头开始处理random指针</div><div class="line">        node1 = head;</div><div class="line">        node2 = new_head;</div><div class="line">        <span class="keyword">while</span> (node1!= NULL) &#123;</div><div class="line">            node2-&gt;random = mp[node1-&gt;random];//node2-&gt;random指向新链表的某个节点，不是原始链表的节点</div><div class="line">            node1 = node1-&gt;next;</div><div class="line">            node2 = node2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> new_head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Demo2-不使用hash-map"><a href="#Demo2-不使用hash-map" class="headerlink" title="Demo2(不使用hash_map)"></a>Demo2(不使用hash_map)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list with a random pointer.</div><div class="line"> * struct RandomListNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     RandomListNode *next, *random;</div><div class="line"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</div><div class="line">        /**</div><div class="line">         * 假设：l1代表原链表中的节点；l2代表新链表中的节点</div><div class="line">         */</div><div class="line">        RandomListNode *new_head, *l1, *l2;</div><div class="line">        <span class="keyword">if</span> (head == NULL) <span class="built_in">return</span> NULL;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 第一步：在每一个l1后面创建一个l2，并让l1指向l2，l2指向下一个l1；</div><div class="line">         */</div><div class="line">        <span class="keyword">for</span> (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123;</div><div class="line">            l2 = new RandomListNode(l1-&gt;label);</div><div class="line">            l2-&gt;next = l1-&gt;next;</div><div class="line">            l1-&gt;next = l2;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 第二步：给l2的random赋值，l1的random的next指向的就是l2的random的目标；</div><div class="line">         */</div><div class="line">        new_head = head-&gt;next;</div><div class="line">        <span class="keyword">for</span> (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123;</div><div class="line">            <span class="keyword">if</span> (l1-&gt;random != NULL) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 第三步：需要将整个链表拆成两个链表，具体做法是让l1的next指向后面的后面；</div><div class="line">         *         l2的next也指向后面的后面。</div><div class="line">         */</div><div class="line">        <span class="keyword">for</span> (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123;</div><div class="line">            l2 = l1-&gt;next;</div><div class="line">            l1-&gt;next = l2-&gt;next;</div><div class="line">            <span class="keyword">if</span> (l2-&gt;next != NULL) l2-&gt;next = l2-&gt;next-&gt;next;//需要判断l2-&gt;next！=NULL,因为如果是NULL的话,NULL没有next,会报错</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> new_head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>在代码中已标明</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/17/LeetCode138/" data-id="cjbbmvx7c0001vwnlga3b3w7a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链表/">链表</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode139" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/09/LeetCode139/" class="article-date">
  <time datetime="2017-12-09T08:49:01.000Z" itemprop="datePublished">2017-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/09/LeetCode139/">LeetCode139. Word Break 140. Word Break II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="external">Description</a></h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>
<p>UPDATE (2017/1/4):<br>The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">given</div><div class="line">s = <span class="string">"leetcode"</span>,</div><div class="line">dict = [<span class="string">"leet"</span>, <span class="string">"code"</span>].</div><div class="line"></div><div class="line">Return <span class="literal">true</span> because <span class="string">"leetcode"</span> can be segmented as <span class="string">"leet code"</span>.</div></pre></td></tr></table></figure>
<h2 id="Demo-动态规划"><a href="#Demo-动态规划" class="headerlink" title="Demo(动态规划)"></a>Demo(动态规划)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</div><div class="line">        int len=s.size();</div><div class="line">        vector&lt;bool&gt;dp(len+1,<span class="literal">false</span>);</div><div class="line">        dp[0]=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(int i=1;i&lt;=len;i++)</div><div class="line">        <span class="keyword">for</span>(int j=0;j&lt;i;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end())//注意vector&lt;string&gt;的find方法 </div><div class="line">                dp[i]=<span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> dp[len];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/word-break-ii/description/" target="_blank" rel="external">Description</a></h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.</p>
<p>Return all such possible sentences.<br>UPDATE (2017/1/4):<br>The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">given</div><div class="line">s = <span class="string">"catsanddog"</span>,</div><div class="line">dict = [<span class="string">"cat"</span>, <span class="string">"cats"</span>, <span class="string">"and"</span>, <span class="string">"sand"</span>, <span class="string">"dog"</span>].</div><div class="line"></div><div class="line">A solution is [<span class="string">"cats and dog"</span>, <span class="string">"cat sand dog"</span>].</div><div class="line">Return <span class="literal">true</span> because <span class="string">"leetcode"</span> can be segmented as <span class="string">"leet code"</span>.</div></pre></td></tr></table></figure>
<h2 id="Demo-dp-dfs"><a href="#Demo-dp-dfs" class="headerlink" title="Demo(dp+dfs)"></a>Demo(dp+dfs)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void buildPaths(vector&lt;bool&gt;&amp;isBreakable,string s,unordered_set&lt;string&gt;&amp;wordSet,int pos,string cur,vector&lt;string&gt;&amp;res,int maxlen,int minlen)</div><div class="line">    &#123;</div><div class="line">        int i,len=s.size();</div><div class="line">        <span class="keyword">for</span>(i=minlen;i&lt;=min(maxlen,len-pos);i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(isBreakable[i+pos]&amp;&amp;wordSet.count(s.substr(pos,i)))</div><div class="line">                <span class="keyword">if</span>(pos+i==len)</div><div class="line">                    res.push_back(cur+s.substr(pos,i));</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    buildPaths(isBreakable,s,wordSet,pos+i,cur+s.substr(pos,i)+<span class="string">" "</span>,res,maxlen,minlen);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</div><div class="line">        unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end());     </div><div class="line">        int size=s.size(),maxlen=INT_MIN,minlen=INT_MAX;</div><div class="line">        int i,len;</div><div class="line">        vector&lt;bool&gt;isBreakable((size+1),<span class="literal">false</span>);</div><div class="line">        vector&lt;string&gt;res;</div><div class="line">        <span class="keyword">for</span>(string word:wordSet)</div><div class="line">        &#123;</div><div class="line">            maxlen=max(maxlen,(int)word.length());</div><div class="line">            minlen=min(minlen,(int)word.length());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(i=size-minlen,isBreakable[size]=<span class="literal">true</span>;i&gt;=0;i--)</div><div class="line">            <span class="keyword">for</span>(len=minlen;len&lt;=min(maxlen,size-i);len++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(isBreakable[i+len]&amp;&amp;wordSet.count(s.substr(i,len)))</div><div class="line">                &#123;</div><div class="line">                    isBreakable[i]=<span class="literal">true</span>;</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">                &#125; </div><div class="line">            &#125;</div><div class="line">        <span class="keyword">if</span>(isBreakable[0])</div><div class="line">            buildPaths(isBreakable,s,wordSet,0,<span class="string">""</span>,res,maxlen,minlen);</div><div class="line">        <span class="built_in">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>The basic idea is to use DP to create an array isBreakable[i] to indicate whether s[i..sSize-1] is breakable.<br>Then we can use such information to help us speed up the DFS path build process (buildPath). Learned from other posts,<br>I first calculated minlen and maxlen to speed up the process.（有点难这个题，摘自LeetCode）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/09/LeetCode139/" data-id="cjbbmvx7r0004vwnlwqywk4tg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode141" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/08/LeetCode141/" class="article-date">
  <time datetime="2017-12-08T01:15:06.000Z" itemprop="datePublished">2017-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/08/LeetCode141/">LeetCode141. Linked List Cycle 142. Linked List Cycle II</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="external">Description</a></h1><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="Demo-快慢指针"><a href="#Demo-快慢指针" class="headerlink" title="Demo(快慢指针)"></a>Demo(快慢指针)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool hasCycle(ListNode *head) &#123;</div><div class="line">        <span class="keyword">if</span>(head==NULL||head-&gt;next==NULL)</div><div class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">        ListNode*slow=head,*fast=head;</div><div class="line">        <span class="keyword">while</span>((fast-&gt;next!=NULL)&amp;&amp;(fast-&gt;next-&gt;next!=NULL))//如果有环肯定不指向空，如果指向空肯定不成环</div><div class="line">        &#123;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">            fast=fast-&gt;next-&gt;next;</div><div class="line">            <span class="keyword">if</span>(slow==fast)</div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>使用快慢指针。如果链表有环，则两指针必在某一时刻相等。</p>
<h1 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="external">Description</a></h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="Demo-快慢指针-1"><a href="#Demo-快慢指针-1" class="headerlink" title="Demo(快慢指针)"></a>Demo(快慢指针)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode *detectCycle(ListNode *head) &#123;</div><div class="line">        <span class="keyword">if</span>(head==NULL||head-&gt;next==NULL)</div><div class="line">            <span class="built_in">return</span> NULL;</div><div class="line">        ListNode*slow=head,*fast=head;</div><div class="line">        <span class="keyword">while</span>(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)//如果有环肯定不指向空，如果指向空肯定不成环</div><div class="line">        &#123;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">            fast=fast-&gt;next-&gt;next;</div><div class="line">            <span class="keyword">if</span>(slow==fast)</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(fast==slow&amp;&amp;fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)</div><div class="line">        &#123;</div><div class="line">            slow=head;</div><div class="line">            <span class="keyword">while</span>(slow!=fast)</div><div class="line">            &#123;</div><div class="line">                slow=slow-&gt;next;</div><div class="line">                fast=fast-&gt;next;</div><div class="line">            &#125;  </div><div class="line">           <span class="built_in">return</span> slow;   </div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> NULL;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/2017/12/08/LeetCode141/introduction.jpg" alt="LeetCode142"><br>思路：<br>如图所示，设链表头是X，环的第一个节点是Y，slow和fast第一次的交点是Z。各段的长度分别是a,b,c。<br>第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b。<br>因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b，可以得到a=c（这个结论很重要！）。<br>我们已经得到了结论a=c，那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇！也就是环的第一个节点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/08/LeetCode141/" data-id="cjbbmvx7r0005vwnl8hj0ouzw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链表/">链表</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode143" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/05/LeetCode143/" class="article-date">
  <time datetime="2017-12-05T10:55:17.000Z" itemprop="datePublished">2017-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/05/LeetCode143/">LeetCode143. Reorder List</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="external">Description</a></h1><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;.</div></pre></td></tr></table></figure>
<h2 id="Demo1-链表"><a href="#Demo1-链表" class="headerlink" title="Demo1(链表)"></a>Demo1(链表)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void reorderList(ListNode* head) &#123;</div><div class="line">        <span class="keyword">if</span>(head==NULL||head-&gt;next==NULL)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        //第一步，先使用快慢指针将链表从中间分割成两段</div><div class="line">        ListNode*slow=head,*fast=head,*p=head,*q=head;</div><div class="line">        <span class="keyword">while</span>(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)</div><div class="line">        &#123;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">            fast=fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        fast=slow-&gt;next,slow-&gt;next=NULL;</div><div class="line">        //第二步，后半段就地逆置</div><div class="line">        p=fast,q=fast-&gt;next,fast-&gt;next=NULL;//注意fast-&gt;next=NULL,有它p就是独立的一个链表了，q的元素不断加到p上，最后p是完整的后半段。</div><div class="line">        <span class="keyword">while</span>(q)</div><div class="line">        &#123;</div><div class="line">            ListNode*tmp=q-&gt;next;</div><div class="line">            q-&gt;next=p;</div><div class="line">            p=q;</div><div class="line">            q=tmp;</div><div class="line">        &#125;</div><div class="line">        //第三步，后半段插入到前半段中</div><div class="line">        q=head;</div><div class="line">        <span class="keyword">while</span>(p&amp;&amp;q)</div><div class="line">        &#123;</div><div class="line">            ListNode*tmp1=q-&gt;next,*tmp2=p-&gt;next;</div><div class="line">            p-&gt;next=q-&gt;next;</div><div class="line">            q-&gt;next=p;</div><div class="line">            q=tmp1;</div><div class="line">            p=tmp2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>先使用快慢指针将链表从中间分割成两段，然后后半段就地逆置．之后合并插入到前半段链表即可，时间复杂度O(n)。<br>这三步已经在代码中标注，每个步骤可灵活运用于别的题目。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/05/LeetCode143/" data-id="cjbbmvx7r0008vwnldnal1jbz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链表/">链表</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode147" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/05/LeetCode147/" class="article-date">
  <time datetime="2017-12-05T08:42:28.000Z" itemprop="datePublished">2017-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/05/LeetCode147/">LeetCode147. Insertion Sort List</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/insertion-sort-list/description/" target="_blank" rel="external">Description</a></h1><p>Sort a linked list using insertion sort.</p>
<h2 id="Demo1-链表的插入排序"><a href="#Demo1-链表的插入排序" class="headerlink" title="Demo1(链表的插入排序)"></a>Demo1(链表的插入排序)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode *insertionSortList(ListNode *head) &#123;</div><div class="line">        ListNode *sortedHead = new ListNode(-1);</div><div class="line">        <span class="keyword">while</span>(head != NULL)</div><div class="line">        &#123;</div><div class="line">            //保存head位置</div><div class="line">            ListNode *temp = head-&gt;next;</div><div class="line">            ListNode *cur = sortedHead;</div><div class="line">            <span class="keyword">while</span>(cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val &lt; head-&gt;val)</div><div class="line">            &#123;</div><div class="line">                cur = cur-&gt;next;</div><div class="line">            &#125;</div><div class="line">            //插入</div><div class="line">            head-&gt;next = cur-&gt;next;</div><div class="line">            cur-&gt;next = head;</div><div class="line">            //恢复head</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> sortedHead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>本题是插入排序的链表版本。</p>
<p>传统数组版本做法就是两重循环，第一重是遍历所有元素，第二重是遍历已排序部分进行插入。</p>
<p>链表版本类似，在遍历每个元素过程中，遍历已排序部分进行插入。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/05/LeetCode147/" data-id="cjbbmvx870009vwnl3nif7t1t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/插入排序/">插入排序</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode148" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/LeetCode148/" class="article-date">
  <time datetime="2017-11-26T04:12:24.000Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/LeetCode148/">LeetCode148. Sort List</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="external">Description</a></h1><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<h2 id="Demo1-用的分治法加递归"><a href="#Demo1-用的分治法加递归" class="headerlink" title="Demo1(用的分治法加递归)"></a>Demo1(用的分治法加递归)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;  </div><div class="line">public:  </div><div class="line">    ListNode *sortList(ListNode *head) &#123;  </div><div class="line">        <span class="keyword">if</span> (head == NULL || head-&gt;next == NULL) <span class="built_in">return</span> head;  </div><div class="line">        ListNode* slower = head; //slower是左1/2链表的尾巴  </div><div class="line">        ListNode* slow = head-&gt;next;//slow是右1/2链表的开始  </div><div class="line">        ListNode* fast = head-&gt;next-&gt;next;//fast每次走2步，slow每次走1步，当fast走到原链表结尾的时候，slow就走到了1/2点了。  </div><div class="line">        <span class="keyword">while</span>(fast != NULL) &#123;  </div><div class="line">            slower = slow;  </div><div class="line">            fast = fast-&gt;next;  </div><div class="line">            slow = slow-&gt;next;  </div><div class="line">            <span class="keyword">if</span>(fast != NULL) fast = fast-&gt;next;  </div><div class="line">        &#125;  </div><div class="line">//        slower = slow; //测试后发现，如果把slow或者slower向右移动一位，可能会造成infinite loop，所以还是应该保持slow就在原链表1/2处的位置。  </div><div class="line">//        slow = slow-&gt;next; //如果使用这个错误版本的代码，&#123;4,3,8,7,2,1,9,5,6,0&#125; 这个例子会有infinite loop。</div><div class="line">        slower-&gt;next = NULL;  </div><div class="line">        ListNode* left = sortList(head);  </div><div class="line">        ListNode* right = sortList(slow);  </div><div class="line">        ListNode* dummy_head = new ListNode(-1); //避免讨论head是不是空。  </div><div class="line">        ListNode* tail = dummy_head;  </div><div class="line">        <span class="keyword">while</span>(left!= NULL &amp;&amp; right != NULL) &#123;  </div><div class="line">            <span class="keyword">if</span> (left-&gt;val &lt; right-&gt;val) &#123;  </div><div class="line">                tail-&gt;next = left;  </div><div class="line">                left = left-&gt;next;  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                tail-&gt;next = right;  </div><div class="line">                right = right-&gt;next;  </div><div class="line">            &#125;  </div><div class="line">            tail = tail-&gt;next;  </div><div class="line">            tail-&gt;next = NULL;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">while</span> (left != NULL) &#123;  </div><div class="line">            tail-&gt;next = left;  </div><div class="line">            left = left-&gt;next;  </div><div class="line">            tail = tail-&gt;next;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">while</span> (right != NULL) &#123;  </div><div class="line">            tail-&gt;next = right;  </div><div class="line">            right = right-&gt;next;  </div><div class="line">            tail = tail-&gt;next;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        ListNode* return_head = dummy_head-&gt;next;  </div><div class="line">        delete dummy_head;  </div><div class="line">        dummy_head = NULL;  </div><div class="line">        <span class="built_in">return</span> return_head;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>挺有意思的一道题目。表面上看，能够有O(n lgn)时间复杂度的算法为，快速排序，堆排序，归并排序，三者的空间复杂度分别为O(1), O(N),O(N)<br>所以一开始，我想着用快速排序的方法来解决，但是发现代码很难写出来。于是网上看了一下提示，发现其实方法选错了。应该使用的方法是归并排序。<br>通常而言，也就是针对数组而言，归并排序的空间复杂度为O(N), 你需要开出O(N)的额外空间来容纳数组，来表示归并后的顺序。但是，对于链表而言，<br>你可以省下这部分空间的开销，你只需要改变节点的next指针的指向，就可以表示新的归并后的顺序了，所以空间复杂度陡然降到了O(1)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/26/LeetCode148/" data-id="cjbbmvx9i000nvwnl7jwrtr25" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链表/">链表</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode150" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/25/LeetCode150/" class="article-date">
  <time datetime="2017-11-25T12:09:51.000Z" itemprop="datePublished">2017-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/25/LeetCode150/">LeetCode150. Evaluate Reverse Polish Notation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/" target="_blank" rel="external">Description</a></h1><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>] -&gt; ((2 + 1) * 3) -&gt; 9</div></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>] -&gt; (4 + (13 / 5)) -&gt; 6</div></pre></td></tr></table></figure>
<h2 id="Demo1-用的栈"><a href="#Demo1-用的栈" class="headerlink" title="Demo1(用的栈)"></a>Demo1(用的栈)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</div><div class="line">        stack&lt;int&gt;s;</div><div class="line">        int l,r;</div><div class="line">        <span class="keyword">for</span>(int i=0;i&lt;tokens.size();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">"+"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l+r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">"-"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l-r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">"*"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l*r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">"/"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l/r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                s.push(atoi((tokens[i]).c_str()));//由字符串转化成数字</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> s.top();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：从左到右遍历表达式的每个数字和字符，遇到数字就进栈，遇到符号，就将栈顶的两个数字取出（注意第一次取出的是右操作数，<br>第二次取出的栈顶数字是左操作数），进行运算，将运算结果压栈，一直到最终获得计算结果（最终的栈顶数字）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/25/LeetCode150/" data-id="cjbbmvx9i000uvwnlxf4pbicg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/栈/">栈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode441" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/20/LeetCode441/" class="article-date">
  <time datetime="2017-11-20T02:50:21.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/20/LeetCode441/">LeetCode441. Arranging Coins</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/arranging-coins/description/" target="_blank" rel="external">Description</a></h1><p>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.</p>
<p>Given n, find the total number of full staircase rows that can be formed.</p>
<p>n is a non-negative integer and fits within the range of a 32-bit signed integer.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">n = 5</div><div class="line"></div><div class="line">The coins can form the following rows:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">Because the 3rd row is incomplete, we <span class="built_in">return</span> 2.</div></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n = 8</div><div class="line"></div><div class="line">The coins can form the following rows:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">Because the 4th row is incomplete, we <span class="built_in">return</span> 3.</div></pre></td></tr></table></figure>
<h2 id="Demo1-用的二分搜索"><a href="#Demo1-用的二分搜索" class="headerlink" title="Demo1(用的二分搜索)"></a>Demo1(用的二分搜索)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int arrangeCoins(int n) &#123;</div><div class="line">        <span class="keyword">if</span> (n &lt;= 1) <span class="built_in">return</span> n;</div><div class="line">        long low = 1, high = n;</div><div class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">            long mid = low + (high - low) / 2;</div><div class="line">            <span class="keyword">if</span> (mid * (mid + 1) / 2 &lt;= n) low = mid + 1;//把1到mid的和和n相比，缩小mid的范围</div><div class="line">            <span class="keyword">else</span> high = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> low - 1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>复杂度为O(lgn)的方法，用到了二分搜索法，我们搜索前i行之和刚好大于n的临界点，<br>这样我们减一个就是能排满的行数，注意我们计算前i行之和有可能会整型溢出，所以<br>我们需要将变量都定义成长整型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/20/LeetCode441/" data-id="cjbbmvxad0012vwnl8h8ofycb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二分法/">二分法</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs/">dfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分法/">二分法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回溯法/">回溯法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/复杂度/">复杂度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插入排序/">插入排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/栈/">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心法/">贪心法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/dfs/" style="font-size: 10px;">dfs</a> <a href="/tags/二分法/" style="font-size: 20px;">二分法</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/回溯法/" style="font-size: 10px;">回溯法</a> <a href="/tags/复杂度/" style="font-size: 10px;">复杂度</a> <a href="/tags/插入排序/" style="font-size: 10px;">插入排序</a> <a href="/tags/栈/" style="font-size: 10px;">栈</a> <a href="/tags/贪心法/" style="font-size: 10px;">贪心法</a> <a href="/tags/链表/" style="font-size: 20px;">链表</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/18/LeetCode134/">LeetCode134. Gas Station</a>
          </li>
        
          <li>
            <a href="/2017/12/17/LeetCode137/">LeetCode137. Single Number II</a>
          </li>
        
          <li>
            <a href="/2017/12/17/LeetCode138/">LeetCode138. Copy List with Random Pointer</a>
          </li>
        
          <li>
            <a href="/2017/12/09/LeetCode139/">LeetCode139. Word Break 140. Word Break II</a>
          </li>
        
          <li>
            <a href="/2017/12/08/LeetCode141/">LeetCode141. Linked List Cycle 142. Linked List Cycle II</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 wang zaozao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>