<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/2018/01/16/snakeGame/index/</url>
      <content type="html"><![CDATA[<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>贪吃蛇</title>
<script>
    var map; //地图类对象
    var snake; //蛇类对象
    var food; //食物类对象
    var timer; //定时器对象
    var sum=0; //分数
    var score;//分数对象
    
    //地图类
    function Map()
    {
        this.width=800; //地图宽度
        this.height=400; //地图高度
        this.position='absolute'; //定位方式
        this.color='#cccccc'; //地图颜色
        this._map=null; //保存地图dom元素
        
        this.show=function()
        {
            //用于显示地图
            //创建地图div元素
            this._map = document.createElement('div');
            //设置地图样式
            this._map.style.width = this.width + 'px';
            this._map.style.height = this.height + 'px';
            this._map.style.position = this.position ;
            this._map.style.backgroundColor = this.color ;
            
            //将地图div元素追加到body标签之间
            document.getElementsByTagName('body')[0].appendChild(this._map);
        };
    }
    
    //食物类
    function Food()
    {
        this.width=20; //宽度
        this.height=20; //高度
        this.position='absolute'; //定位方式
        this.color='#00ff00'; //食物颜色
        this._food=null; //用于保存食物dom元素
        this.x=0; //横向第几个格
        this.y=0; //纵向第几个格
        
        this.show=function()
        {
            //用于显示食物
            if(this._food==null)
            {
                this._food=document.createElement('div');
                
                //设置食物样式
                this._food.style.width = this.width + 'px';
                this._food.style.height = this.height + 'px';
                this._food.style.position = this.position ;
                this._food.style.backgroundColor = this.color ;
                
                map._map.appendChild(this._food);
            }
            //如果之前创建过，只需要重新设置坐标
            this.x=Math.floor(Math.random()*40);
            this.y=Math.floor(Math.random()*20);
            this._food.style.left = this.x*this.width+'px';
            this._food.style.top = this.y*this.height+'px';
        };
    }
  	//分数
  	function Score()
  	{
        this.width=60; //宽度
        this.height=20; //高度
        this.position='absolute'; //定位方式
        this.color='#00ff00'; //食物颜色
        this._score=null; //用于保存分数dom元素

        
        this.show=function()
        {
            //用于显示分数
            if(this._score==null)
            {
                this._score=document.createElement('p');
                
                //设置分数样式
                this._score.style.width = this.width + 'px';
                this._score.style.height = this.height + 'px';
                this._score.style.position = this.position ;
                this._score.style.color='red';
                this._score.style.fontSize='10px';   
                map._map.appendChild(this._score);
            }
            //如果之前创建过，只需要重新设置坐标
            this._score.innerText='分数:'+sum;
            this._score.style.marginTop='4px';
            this._score.style.left = '740px';
            this._score.style.top =  '0px';
        };
  	}    
    //蛇类
    function Snake()
    {
        this.width=20;    //蛇节宽度
        this.height=20;    //蛇节高度
        this.position='absolute'; //蛇节定位方式
        this.direct=''; //蛇的移动方向
        //所有蛇节全部信息
        this.body=[[3,2,'red',null],[2,2,'blue',null],[1,2,'blue',null]];//第四个元素是蛇节借以显示的div，所以样式都通过改变它来改变
        
        this.setDirect = function(code)
        {
            switch(code)
            {
                case 37:
                    this.direct='left';
                    break;
                case 38:
                    this.direct='up';
                    break;
                case 39:
                    this.direct='right';
                    break;
                case 40:
                    this.direct='down';
                    break;
            }
        }
        
        this.show=function()
        {
            //用于显示蛇
            for(var i=0;i<this.body.length;i++)
            {
            	//如果蛇节没有被创建
                if(this.body[i][3]==null)
                {
                    this.body[i][3] = document.createElement('div');
                    this.body[i][3].style.width = this.width +'px';
                    this.body[i][3].style.height = this.height +'px';
                    this.body[i][3].style.position = this.position;
                    this.body[i][3].style.backgroundColor = this.body[i][2];//在蛇吃到食物事件里已添加前面两个元素的值，现在就可以加以引用
                    map._map.appendChild(this.body[i][3]);
                }
                //设置蛇节的横纵坐标
                this.body[i][3].style.left=this.body[i][0]*this.width+'px';
                this.body[i][3].style.top=this.body[i][1]*this.height+'px';
            }
        }
        
        this.move = function()
        {
            //移动蛇身
            var length = this.body.length-1;
            
            for(var i=length;i>0;i--)
            {
                //让后面的蛇节的坐标等于前面蛇节的坐标
                this.body[i][0]=this.body[i-1][0]; //横坐标
                this.body[i][1]=this.body[i-1][1]; //纵坐标
                
            }
            switch(this.direct)
            {
                case 'right':
                    this.body[0][0]=this.body[0][0]+1;
                    break;
                case 'down':
                    this.body[0][1]=this.body[0][1]+1;
                    break;
                case 'left':
                    this.body[0][0]=this.body[0][0]-1;
                    break;
                case 'up':
                    this.body[0][1]=this.body[0][1]-1;
                    break;
                default:
                    return;
            }
            
            //判断蛇吃到食物
            if(this.body[0][0]==food.x&&this.body[0][1]==food.y)
            {
                var x=this.body[length][0];//前面已定义length = this.body.length-1;
                var y=this.body[length][1];
                sum++;
                score.show();//score已经定义为全局对象，而且在window.onload里已经实例化，可以直接调用Score类里面的函数
                //document.title='分数:'+sum+'分';
                this.body.push([x,y,'blue',null]);
                food.show();
            }
            
            //判断撞墙死
            if(this.body[0][0]<0 || this.body[0][0]>39 ||this.body[0][1]<0 ||this.body[0][1]>19)
            {
             //   alert('撞墙死');
                clearTimeout(timer);
                return;
            }
            
            //吃到自己死
            for(var i=1;i<this.body.length;i++)
            {
                if(this.body[0][0]==this.body[i][0]&&this.body[0][1]==this.body[i][1])
                {
               //     alert('吃到自己死');
                    clearTimeout(timer);
                    return;
                }
            }
            
            this.show();
        }
    }

    
    window.onload = function()
    {
    	var lastDirect=39;//保存上次的方向
        map = new Map(); //实例化地图类对象
        map.show();    //显示地图
        
        
        food=new Food(); //实例化食物类对象
        food.show(); //显示食物
        
        score=new Score();//实例化分数类对象
        score.show();//显示分数
        
        snake = new Snake(); //实例化蛇类对象
        snake.show();
        timer = setInterval('snake.move()',200);
        
        document.onkeydown = function()
        {
            var code;
            if(window.event)
            {
                code=window.event.keyCode;
            }else
            {
                code = event.keyCode;
            }
            if(Math.abs(code-lastDirect)!=2)//如果这次的方向和上次不相反时才改变方向
        	{
        		snake.setDirect(code);
        		lastDirect=code;
        	}
        };
            
    }
</script>
</head>
<body>

</body>
</html>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[snakeGame]]></title>
      <url>/2018/01/16/snakeGame/</url>
      <content type="html"><![CDATA[<p>这是一个贪吃蛇游戏<br><a href="/snakeGame/index.html">点击进入</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 小游戏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode123. Best Time to Buy and Sell Stock III]]></title>
      <url>/2018/01/10/LeetCode123/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="external">Description</a></h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h2 id="Demo-局部最优和全局最优"><a href="#Demo-局部最优和全局最优" class="headerlink" title="Demo(局部最优和全局最优)"></a>Demo(局部最优和全局最优)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</div><div class="line">        int n=prices.size();</div><div class="line">        <span class="keyword">if</span>(n==0)</div><div class="line">            <span class="built_in">return</span> 0;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; <span class="built_in">local</span>(n, vector&lt;int&gt;(3, 0));</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; global(n, vector&lt;int&gt;(3, 0));</div><div class="line">        <span class="keyword">for</span>(int i=1;i&lt;n;i++)//第一天局部收益和全局收益都为0,所以从第二天算起</div><div class="line">        &#123;</div><div class="line">            int diff=prices[i]-prices[i-1];</div><div class="line">            <span class="keyword">for</span>(int j=1;j&lt;=2;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">local</span>[i][j]=max(global[i-1][j-1]+max(0,diff),<span class="built_in">local</span>[i-1][j]+diff);//max中最后一个参数是+diff，因为<span class="built_in">local</span>是今天卖出最后一笔股票</div><div class="line">                global[i][j]=max(global[i-1][j],<span class="built_in">local</span>[i][j]);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> global[n-1][2];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>这里我们需要两个递推公式来分别更新两个变量local和global，我们其实可以求至少k次交易的最大利润，找到通解后可以设定 k = 2，即为本题的解答。我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为：<br>local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)<br>global[i][j] = max(local[i][j], global[i - 1][j])<br>其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值中取较大值，而全局最优比较局部最优和前一天的全局最优。<br>ps:这道题其实挺难的，同时用到了局部最优和全局最优</p>
]]></content>
      
        
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode125. Valid Palindrome]]></title>
      <url>/2017/12/31/LeetCode125/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="external">Description</a></h1><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"A man, a plan, a canal: Panama"</span> is a palindrome.</div><div class="line"><span class="string">"race a car"</span> is not a palindrome.</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPalindrome(string s) &#123;</div><div class="line">        <span class="keyword">for</span>(int i=0,j=s.size()-1;i&lt;j;i++,j--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(!isalnum(s[i])&amp;&amp;i&lt;j)i++;</div><div class="line">            <span class="keyword">while</span>(!isalnum(s[j])&amp;&amp;i&lt;j)j--;</div><div class="line">            <span class="keyword">if</span>(toupper(s[i])!=toupper(s[j]))//判断不区分大小写字母是否相等的方法</div><div class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode129. Sum Root to Leaf Numbers]]></title>
      <url>/2017/12/29/LeetCode129/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" target="_blank" rel="external">Description</a></h1><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    1</div><div class="line">   / \</div><div class="line">  2   3</div><div class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</div><div class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</div><div class="line"></div><div class="line">Return the sum = 12 + 13 = 25.</div></pre></td></tr></table></figure>
<h2 id="Demo-递归"><a href="#Demo-递归" class="headerlink" title="Demo(递归)"></a>Demo(递归)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int sumNumbers(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">return</span> dfs(root,0);</div><div class="line">    &#125;</div><div class="line">    int dfs(TreeNode*root,int sum)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(root==NULL)</div><div class="line">            <span class="built_in">return</span> 0;</div><div class="line">        sum=sum*10+root-&gt;val;</div><div class="line">        <span class="keyword">if</span>(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)</div><div class="line">            <span class="built_in">return</span> sum;</div><div class="line">        <span class="built_in">return</span> dfs(root-&gt;left,sum)+dfs(root-&gt;right,sum);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>用递归是比较自然的想法，节点可能出现的情况:<br>(1)左孩子或者右孩子两个都为NULL(叶节点)，此时递归返回。<br>(2)左孩子或者右孩子某一个为NULL，此时继续推进下一层调用，只是在下一层中，会发现有一个为NULL节点，走到NULL节点当然应该返回了。<br>(3)左孩子或者右孩子都不为NULL，此时继续推进下一层的调用。<br>虽然(2)和(3)都是继续推进下一层的调用，但是由于(2)会遇到NULL节点，对于这个特殊情况，需要写句话处理一下。<br>ps:递归要想清楚这些问题。(1)要用到什么参数 (2)节点都有哪些情况? (3)递归什么时候返回？</p>
]]></content>
      
        
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode132. Palindrome Partitioning II]]></title>
      <url>/2017/12/27/LeetCode132/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/palindrome-partitioning-ii/description/" target="_blank" rel="external">Description</a></h1><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">given s = <span class="string">"aab"</span>,</div><div class="line">Return 1 since the palindrome partitioning [<span class="string">"aa"</span>,<span class="string">"b"</span>] could be produced using 1 cut.</div></pre></td></tr></table></figure>
<h2 id="Demo-动态规划"><a href="#Demo-动态规划" class="headerlink" title="Demo(动态规划)"></a>Demo(动态规划)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minCut(string s) &#123;</div><div class="line">        int n=s.size();</div><div class="line">        vector&lt;vector&lt;int&gt;&gt;dp(n, vector&lt;int&gt;(n, 0));</div><div class="line">        vector&lt;int&gt;cut(n+1,INT_MAX);</div><div class="line">        cut[n]=0;</div><div class="line">        <span class="keyword">for</span>(int i=n-1;i&gt;=0;i--)</div><div class="line">        &#123;</div><div class="line">            //cut[i]=INT_MAX;</div><div class="line">            <span class="keyword">for</span>(int j=i;j&lt;n;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;(j-i&lt;=1||dp[i+1][j-1]==1))//一激动就把大小号写反，-_-||</div><div class="line">                &#123;</div><div class="line">                    dp[i][j]=1;</div><div class="line">                    cut[i]=min(cut[j+1]+1,cut[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> cut[0]-1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>对于一个字符串，我们需要考虑所有可能的分割，这个问题可以抽象成一个DP问题，对于一个长度为n的字符串，设DP[i][j]表示第i个字符到第j个字符是否构成回文，若是，则DP[i][j]=1;若否，则DP[i][j]=0;如此，根据回文的约束条件（对称性），DP[i][j]构成回文需满足：<br>1、输入字符串s[i]==s[j],对称性；<br>2、条件1满足并不能保证i到j构成回文，还须：（j-i）&lt;=1或者DP[i+1][j-1]=1；即，i、j相邻或者i=j，也就是相邻字符相等构成回文或者字符自身构成回文，如果i、j不相邻或者相等，i到j构成回文的前提就是DP[i+1][j-1]=1.<br>cut[i]表示第i个字符到最后一个字符所构成的子串的最小分割次数，这里的i有约束条件，就是第i个位置必须是可进行回文分割的，即DP[i][j]==1 (j&gt;=i&amp;&amp;j&lt;s.length())</p>
]]></content>
      
        
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode131. Palindrome Partitioning]]></title>
      <url>/2017/12/27/LeetCode131/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="external">Description</a></h1><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">given s = <span class="string">"aab"</span>,</div><div class="line">Return</div><div class="line"></div><div class="line">[</div><div class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</div><div class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="Demo-回溯法"><a href="#Demo-回溯法" class="headerlink" title="Demo(回溯法)"></a>Demo(回溯法)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</div><div class="line">        vector&lt;vector&lt;string&gt;&gt;res;</div><div class="line">        vector&lt;string&gt;path;</div><div class="line">        helper(s,0,res,path);</div><div class="line">        <span class="built_in">return</span> res;</div><div class="line">    &#125;</div><div class="line">    void helper(string s,int pos,vector&lt;vector&lt;string&gt;&gt;&amp;res,vector&lt;string&gt;&amp;path)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pos==s.size())</div><div class="line">        &#123;</div><div class="line">            res.push_back(path);</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(int i=pos;i&lt;s.size();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(isPalindrome(s.substr(pos,i-pos+1)))</div><div class="line">            &#123;</div><div class="line">                path.push_back(s.substr(pos,i-pos+1));</div><div class="line">                helper(s,i+1,res,path);</div><div class="line">                path.pop_back();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    bool isPalindrome(string s)</div><div class="line">    &#123;</div><div class="line">        int start=0;</div><div class="line">        int end=s.size()-1;</div><div class="line">        <span class="keyword">while</span>(start&lt;end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[start++]!=s[end--])//注意是end--</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>于是感觉对于一个字符串，可以对这个字符串进行遍历，如果前pos个字符串本身是个回文字符，那么只需要求解后面的子字符的回文串即可，于是这个问题被分解成了一个更小的问题。这道题更像一个分治法的题，将问题规模不断缩小，当然的遍历字符串的过程中需要进行回溯。除了需要一个进行递归的辅助函数外，还需要定义一个判断一个字符串是否是回文字符串的辅助函数，程序的逻辑非常简单。<br>这种回溯法题不会多总结，多找规律啊</p>
]]></content>
      
        
        <tags>
            
            <tag> 回溯法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode133. Clone Graph]]></title>
      <url>/2017/12/18/LeetCode133/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/clone-graph/description/" target="_blank" rel="external">Description</a></h1><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Visually, the graph looks like the following:</div><div class="line">       1</div><div class="line">      / \</div><div class="line">     /   \</div><div class="line">    0 --- 2</div><div class="line">         / \</div><div class="line">         \_/</div></pre></td></tr></table></figure>
<h2 id="Demo1-bfs"><a href="#Demo1-bfs" class="headerlink" title="Demo1(bfs)"></a>Demo1(bfs)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> undirected graph.</div><div class="line"> * struct UndirectedGraphNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</div><div class="line"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123;</div><div class="line">        <span class="keyword">if</span>(node==NULL)</div><div class="line">            <span class="built_in">return</span> NULL;</div><div class="line">        unordered_map&lt;UndirectedGraphNode*,UndirectedGraphNode*&gt;<span class="built_in">hash</span>;</div><div class="line">        <span class="built_in">hash</span>[node]=new UndirectedGraphNode(node-&gt;label);//这个语句既创建了新节点，又将新节点的引用(<span class="built_in">hash</span>[node])和原节点(node)用<span class="built_in">hash</span>一一对应起来</div><div class="line">        queue&lt;UndirectedGraphNode*&gt;que;</div><div class="line">        que.push(node);</div><div class="line">        <span class="keyword">while</span>(!que.empty())</div><div class="line">        &#123;</div><div class="line">            UndirectedGraphNode*curNode=que.front();</div><div class="line">            que.pop();</div><div class="line">            <span class="keyword">for</span>(auto neigh:curNode-&gt;neighbors)//以后也可以这样用</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(hash.find(neigh)==hash.end())//如果其某个邻居没被创建，才创建一个，并将这个邻居加入到遍历的队伍</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">hash</span>[neigh]=new UndirectedGraphNode(neigh-&gt;label);</div><div class="line">                    que.push(neigh);</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">hash</span>[curNode]-&gt;neighbors.push_back(<span class="built_in">hash</span>[neigh]);//不管这个邻居有没有被创建，都是我这个节点的邻居，都需要加入到我的邻居数组里</div><div class="line">            &#125;</div><div class="line">           </div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> <span class="built_in">hash</span>[node];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Demo2-dfs"><a href="#Demo2-dfs" class="headerlink" title="Demo2(dfs)"></a>Demo2(dfs)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> undirected graph.</div><div class="line"> * struct UndirectedGraphNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</div><div class="line"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    unordered_map&lt;UndirectedGraphNode*,UndirectedGraphNode*&gt;<span class="built_in">hash</span>;</div><div class="line">    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123;</div><div class="line">        <span class="keyword">if</span>(node==NULL)</div><div class="line">            <span class="built_in">return</span> node;</div><div class="line">        <span class="keyword">if</span>(hash.count(node))</div><div class="line">            <span class="built_in">return</span> <span class="built_in">hash</span>[node];</div><div class="line">        <span class="built_in">hash</span>[node]=new UndirectedGraphNode(node-&gt;label);</div><div class="line">        <span class="keyword">for</span>(auto neigh:node-&gt;neighbors)</div><div class="line">            <span class="built_in">hash</span>[node]-&gt;neighbors.push_back(cloneGraph(neigh));</div><div class="line">        <span class="built_in">return</span> <span class="built_in">hash</span>[node];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>克隆图的一个难点就是一个结点的邻居可能在已经出现过，这样你只要把他的指针加到邻居集合中即可，也有可能这个结点还没出现过，因此你需要新建一个这个结点，因此我们需要一个hash表来对结点做一一映射．<br>本题有两种方法来做，广度搜索BFS和深度搜索DFS.</p>
<ol>
<li>广度搜索BFS<br>利用队列，每次遍历队列头结点所有的邻居，如果其某个邻居还没有被创建，那就创建一个，并且将其加入到队列中去．否则说明这个结点已经被创建，而我们只在一个结点刚被创建时才将其加入到队列中去，因此这个结点已经被创建我们就没必要将其入队列了．每次遍历完之后就克隆好了一个结点和其邻居．然后直到队列为空，我们就完成了克隆的操作．</li>
</ol>
<p>２．深度搜索DFS<br>DFS利用递归一般可以写出比BFS更优雅整洁的代码．<br>每次搜索的时候看这个结点是不是已经被创建，是的话就返回其copy，否则就创建，然后再依次深度遍历其邻居结点并将其加入邻居集合中去．<br>ps:凭我刷了这么多bfs和dfs题的经验，我感觉bfs就是用队列，dfs就是用递归٩(๑❛ᴗ❛๑)۶</p>
]]></content>
      
        
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode134. Gas Station]]></title>
      <url>/2017/12/18/LeetCode134/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/gas-station/description/" target="_blank" rel="external">Description</a></h1><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br>The solution is guaranteed to be unique.</p>
<h2 id="Demo-用了一个数学定理"><a href="#Demo-用了一个数学定理" class="headerlink" title="Demo(用了一个数学定理)"></a>Demo(用了一个数学定理)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123;</div><div class="line">  int start = 0; // 起始位置</div><div class="line">  int remain = 0; // 当前剩余燃料</div><div class="line">  int debt = 0; // 前面没能走完的路上欠的债</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (int i = 0; i &lt; gas.size(); i++) &#123;</div><div class="line">    remain += gas[i] - cost[i];</div><div class="line">    <span class="keyword">if</span> (remain &lt; 0) &#123;</div><div class="line">      debt += remain;</div><div class="line">      start = i + 1;</div><div class="line">      remain = 0;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">return</span> remain + debt &gt;= 0 ? start : -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//思路：<br>非常经典的一道题。可以转换成求最大连续和做，但是有更简单的方法。基于一个数学定理：</p>
<p>如果一个数组的总和非负，那么一定可以找到一个起始位置，从他开始绕数组一圈，累加和一直都是非负的<br>有了这个定理，判断到底是否存在这样的解非常容易，只需要把全部的油耗情况计算出来看看是否大于等于0即可。</p>
<p>那么如何求开始位置在哪？</p>
<p>注意到这样一个现象：</p>
<ol>
<li>假如从位置i开始，i+1，i+2…，一路开过来一路油箱都没有空。说明什么？说明从i到i+1，i+2，…肯定是正积累。</li>
<li>现在突然发现开往位置j时油箱空了。这说明什么？说明从位置i开始没法走完全程(废话)。那么，我们要从位置i+1开始重新尝试吗？不需要！为什么？因为前面已经知道，位置i肯定是正积累，那么，如果从位置i+1开始走更加没法走完全程了，因为没有位置i的正积累了。同理，也不用从i+2，i+3，…开始尝试。所以我们可以放心地从位置j+1开始尝试。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 贪心法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode137. Single Number II]]></title>
      <url>/2017/12/17/LeetCode137/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/single-number-ii/description/" target="_blank" rel="external">Description</a></h1><p>Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<h2 id="Demo-按位与或"><a href="#Demo-按位与或" class="headerlink" title="Demo(按位与或)"></a>Demo(按位与或)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int length=nums.size();</div><div class="line">        int result=0;</div><div class="line">        <span class="keyword">for</span>(int i=0;i&lt;32;i++)</div><div class="line">        &#123;</div><div class="line">            int count=0;</div><div class="line">            int mask=1&lt;&lt;i;//设置某一位为一，方便后面的按位与或操作</div><div class="line">            <span class="keyword">for</span>(int j=0;j&lt;length;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums[j]&amp;mask)</div><div class="line">                    count++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(count%3)</div><div class="line">                result|=mask;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>考虑每个元素的为一个32位的二进制数，这样每一位上出现要么为1，要么为0。对数组，统计每一位上1 出现的次数count，必定是3N或者3N+1 次。让count对3取模，能够获得到那个只出现1次的元素该位是0还是1。</p>
]]></content>
      
        
        <tags>
            
            <tag> 复杂度 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode138. Copy List with Random Pointer]]></title>
      <url>/2017/12/17/LeetCode138/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="external">Description</a></h1><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="Demo1-使用hash-map"><a href="#Demo1-使用hash-map" class="headerlink" title="Demo1(使用hash_map)"></a>Demo1(使用hash_map)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list with a random pointer.</div><div class="line"> * struct RandomListNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     RandomListNode *next, *random;</div><div class="line"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</div><div class="line">        <span class="keyword">if</span> (!head) <span class="built_in">return</span> NULL;</div><div class="line">        unordered_map&lt;RandomListNode*, RandomListNode*&gt; mp;</div><div class="line">        // 创建一个新的链表头</div><div class="line">        RandomListNode *new_head = new RandomListNode(head-&gt;label);</div><div class="line">        // node1负责指向原链表，node2负责指向新链表</div><div class="line">        RandomListNode *node1 = head, *node2 = new_head;</div><div class="line">        /**</div><div class="line">         * 按照原链表的结构不断创建新的节点，并维护好next指针，将node1与node2的对应关系保存到hash_map中，</div><div class="line">         * 以备后面维护random指针的时候，可以通过node1找到对应的node2。</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span> (node1-&gt;next != NULL) &#123;</div><div class="line">            mp[node1] = node2;</div><div class="line">            node1 = node1-&gt;next;</div><div class="line">            node2-&gt;next = new RandomListNode(node1-&gt;label);</div><div class="line">            node2 = node2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        // 将两个链表的尾巴的对应关系也保存好</div><div class="line">        mp[node1] = node2;</div><div class="line">        </div><div class="line">        // 继续从头开始处理random指针</div><div class="line">        node1 = head;</div><div class="line">        node2 = new_head;</div><div class="line">        <span class="keyword">while</span> (node1!= NULL) &#123;</div><div class="line">            node2-&gt;random = mp[node1-&gt;random];//node2-&gt;random指向新链表的某个节点，不是原始链表的节点</div><div class="line">            node1 = node1-&gt;next;</div><div class="line">            node2 = node2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> new_head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Demo2-不使用hash-map"><a href="#Demo2-不使用hash-map" class="headerlink" title="Demo2(不使用hash_map)"></a>Demo2(不使用hash_map)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list with a random pointer.</div><div class="line"> * struct RandomListNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     RandomListNode *next, *random;</div><div class="line"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    RandomListNode *copyRandomList(RandomListNode *head) &#123;</div><div class="line">        /**</div><div class="line">         * 假设：l1代表原链表中的节点；l2代表新链表中的节点</div><div class="line">         */</div><div class="line">        RandomListNode *new_head, *l1, *l2;</div><div class="line">        <span class="keyword">if</span> (head == NULL) <span class="built_in">return</span> NULL;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 第一步：在每一个l1后面创建一个l2，并让l1指向l2，l2指向下一个l1；</div><div class="line">         */</div><div class="line">        <span class="keyword">for</span> (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123;</div><div class="line">            l2 = new RandomListNode(l1-&gt;label);</div><div class="line">            l2-&gt;next = l1-&gt;next;</div><div class="line">            l1-&gt;next = l2;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 第二步：给l2的random赋值，l1的random的next指向的就是l2的random的目标；</div><div class="line">         */</div><div class="line">        new_head = head-&gt;next;</div><div class="line">        <span class="keyword">for</span> (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123;</div><div class="line">            <span class="keyword">if</span> (l1-&gt;random != NULL) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 第三步：需要将整个链表拆成两个链表，具体做法是让l1的next指向后面的后面；</div><div class="line">         *         l2的next也指向后面的后面。</div><div class="line">         */</div><div class="line">        <span class="keyword">for</span> (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123;</div><div class="line">            l2 = l1-&gt;next;</div><div class="line">            l1-&gt;next = l2-&gt;next;</div><div class="line">            <span class="keyword">if</span> (l2-&gt;next != NULL) l2-&gt;next = l2-&gt;next-&gt;next;//需要判断l2-&gt;next！=NULL,因为如果是NULL的话,NULL没有next,会报错</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> new_head;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>在代码中已标明</p>
]]></content>
      
        
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode139. Word Break 140. Word Break II]]></title>
      <url>/2017/12/09/LeetCode139/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="external">Description</a></h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>
<p>UPDATE (2017/1/4):<br>The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">given</div><div class="line">s = <span class="string">"leetcode"</span>,</div><div class="line">dict = [<span class="string">"leet"</span>, <span class="string">"code"</span>].</div><div class="line"></div><div class="line">Return <span class="literal">true</span> because <span class="string">"leetcode"</span> can be segmented as <span class="string">"leet code"</span>.</div></pre></td></tr></table></figure>
<h2 id="Demo-动态规划"><a href="#Demo-动态规划" class="headerlink" title="Demo(动态规划)"></a>Demo(动态规划)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</div><div class="line">        int len=s.size();</div><div class="line">        vector&lt;bool&gt;dp(len+1,<span class="literal">false</span>);</div><div class="line">        dp[0]=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(int i=1;i&lt;=len;i++)</div><div class="line">        <span class="keyword">for</span>(int j=0;j&lt;i;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end())//注意vector&lt;string&gt;的find方法 </div><div class="line">                dp[i]=<span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> dp[len];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/word-break-ii/description/" target="_blank" rel="external">Description</a></h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.</p>
<p>Return all such possible sentences.<br>UPDATE (2017/1/4):<br>The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">given</div><div class="line">s = <span class="string">"catsanddog"</span>,</div><div class="line">dict = [<span class="string">"cat"</span>, <span class="string">"cats"</span>, <span class="string">"and"</span>, <span class="string">"sand"</span>, <span class="string">"dog"</span>].</div><div class="line"></div><div class="line">A solution is [<span class="string">"cats and dog"</span>, <span class="string">"cat sand dog"</span>].</div><div class="line">Return <span class="literal">true</span> because <span class="string">"leetcode"</span> can be segmented as <span class="string">"leet code"</span>.</div></pre></td></tr></table></figure>
<h2 id="Demo-dp-dfs"><a href="#Demo-dp-dfs" class="headerlink" title="Demo(dp+dfs)"></a>Demo(dp+dfs)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void buildPaths(vector&lt;bool&gt;&amp;isBreakable,string s,unordered_set&lt;string&gt;&amp;wordSet,int pos,string cur,vector&lt;string&gt;&amp;res,int maxlen,int minlen)</div><div class="line">    &#123;</div><div class="line">        int i,len=s.size();</div><div class="line">        <span class="keyword">for</span>(i=minlen;i&lt;=min(maxlen,len-pos);i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(isBreakable[i+pos]&amp;&amp;wordSet.count(s.substr(pos,i)))</div><div class="line">                <span class="keyword">if</span>(pos+i==len)</div><div class="line">                    res.push_back(cur+s.substr(pos,i));</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    buildPaths(isBreakable,s,wordSet,pos+i,cur+s.substr(pos,i)+<span class="string">" "</span>,res,maxlen,minlen);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</div><div class="line">        unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end());     </div><div class="line">        int size=s.size(),maxlen=INT_MIN,minlen=INT_MAX;</div><div class="line">        int i,len;</div><div class="line">        vector&lt;bool&gt;isBreakable((size+1),<span class="literal">false</span>);</div><div class="line">        vector&lt;string&gt;res;</div><div class="line">        <span class="keyword">for</span>(string word:wordSet)</div><div class="line">        &#123;</div><div class="line">            maxlen=max(maxlen,(int)word.length());</div><div class="line">            minlen=min(minlen,(int)word.length());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(i=size-minlen,isBreakable[size]=<span class="literal">true</span>;i&gt;=0;i--)</div><div class="line">            <span class="keyword">for</span>(len=minlen;len&lt;=min(maxlen,size-i);len++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(isBreakable[i+len]&amp;&amp;wordSet.count(s.substr(i,len)))</div><div class="line">                &#123;</div><div class="line">                    isBreakable[i]=<span class="literal">true</span>;</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">                &#125; </div><div class="line">            &#125;</div><div class="line">        <span class="keyword">if</span>(isBreakable[0])</div><div class="line">            buildPaths(isBreakable,s,wordSet,0,<span class="string">""</span>,res,maxlen,minlen);</div><div class="line">        <span class="built_in">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//思路：<br>The basic idea is to use DP to create an array isBreakable[i] to indicate whether s[i..sSize-1] is breakable.<br>Then we can use such information to help us speed up the DFS path build process (buildPath). Learned from other posts,<br>I first calculated minlen and maxlen to speed up the process.（有点难这个题，摘自LeetCode）</p>
]]></content>
      
        
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode141. Linked List Cycle 142. Linked List Cycle II]]></title>
      <url>/2017/12/08/LeetCode141/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="external">Description</a></h1><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="Demo-快慢指针"><a href="#Demo-快慢指针" class="headerlink" title="Demo(快慢指针)"></a>Demo(快慢指针)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool hasCycle(ListNode *head) &#123;</div><div class="line">        <span class="keyword">if</span>(head==NULL||head-&gt;next==NULL)</div><div class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">        ListNode*slow=head,*fast=head;</div><div class="line">        <span class="keyword">while</span>((fast-&gt;next!=NULL)&amp;&amp;(fast-&gt;next-&gt;next!=NULL))//如果有环肯定不指向空，如果指向空肯定不成环</div><div class="line">        &#123;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">            fast=fast-&gt;next-&gt;next;</div><div class="line">            <span class="keyword">if</span>(slow==fast)</div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>使用快慢指针。如果链表有环，则两指针必在某一时刻相等。</p>
<h1 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="external">Description</a></h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="Demo-快慢指针-1"><a href="#Demo-快慢指针-1" class="headerlink" title="Demo(快慢指针)"></a>Demo(快慢指针)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode *detectCycle(ListNode *head) &#123;</div><div class="line">        <span class="keyword">if</span>(head==NULL||head-&gt;next==NULL)</div><div class="line">            <span class="built_in">return</span> NULL;</div><div class="line">        ListNode*slow=head,*fast=head;</div><div class="line">        <span class="keyword">while</span>(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)//如果有环肯定不指向空，如果指向空肯定不成环</div><div class="line">        &#123;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">            fast=fast-&gt;next-&gt;next;</div><div class="line">            <span class="keyword">if</span>(slow==fast)</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(fast==slow&amp;&amp;fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)</div><div class="line">        &#123;</div><div class="line">            slow=head;</div><div class="line">            <span class="keyword">while</span>(slow!=fast)</div><div class="line">            &#123;</div><div class="line">                slow=slow-&gt;next;</div><div class="line">                fast=fast-&gt;next;</div><div class="line">            &#125;  </div><div class="line">           <span class="built_in">return</span> slow;   </div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> NULL;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/2017/12/08/LeetCode141/introduction.jpg" alt="LeetCode142"><br>思路：<br>如图所示，设链表头是X，环的第一个节点是Y，slow和fast第一次的交点是Z。各段的长度分别是a,b,c。<br>第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b。<br>因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b，可以得到a=c（这个结论很重要！）。<br>我们已经得到了结论a=c，那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇！也就是环的第一个节点。</p>
]]></content>
      
        
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode143. Reorder List]]></title>
      <url>/2017/12/05/LeetCode143/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="external">Description</a></h1><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;.</div></pre></td></tr></table></figure>
<h2 id="Demo1-链表"><a href="#Demo1-链表" class="headerlink" title="Demo1(链表)"></a>Demo1(链表)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void reorderList(ListNode* head) &#123;</div><div class="line">        <span class="keyword">if</span>(head==NULL||head-&gt;next==NULL)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        //第一步，先使用快慢指针将链表从中间分割成两段</div><div class="line">        ListNode*slow=head,*fast=head,*p=head,*q=head;</div><div class="line">        <span class="keyword">while</span>(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)</div><div class="line">        &#123;</div><div class="line">            slow=slow-&gt;next;</div><div class="line">            fast=fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        fast=slow-&gt;next,slow-&gt;next=NULL;</div><div class="line">        //第二步，后半段就地逆置</div><div class="line">        p=fast,q=fast-&gt;next,fast-&gt;next=NULL;//注意fast-&gt;next=NULL,有它p就是独立的一个链表了，q的元素不断加到p上，最后p是完整的后半段。</div><div class="line">        <span class="keyword">while</span>(q)</div><div class="line">        &#123;</div><div class="line">            ListNode*tmp=q-&gt;next;</div><div class="line">            q-&gt;next=p;</div><div class="line">            p=q;</div><div class="line">            q=tmp;</div><div class="line">        &#125;</div><div class="line">        //第三步，后半段插入到前半段中</div><div class="line">        q=head;</div><div class="line">        <span class="keyword">while</span>(p&amp;&amp;q)</div><div class="line">        &#123;</div><div class="line">            ListNode*tmp1=q-&gt;next,*tmp2=p-&gt;next;</div><div class="line">            p-&gt;next=q-&gt;next;</div><div class="line">            q-&gt;next=p;</div><div class="line">            q=tmp1;</div><div class="line">            p=tmp2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>先使用快慢指针将链表从中间分割成两段，然后后半段就地逆置．之后合并插入到前半段链表即可，时间复杂度O(n)。<br>这三步已经在代码中标注，每个步骤可灵活运用于别的题目。</p>
]]></content>
      
        
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode147. Insertion Sort List]]></title>
      <url>/2017/12/05/LeetCode147/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/insertion-sort-list/description/" target="_blank" rel="external">Description</a></h1><p>Sort a linked list using insertion sort.</p>
<h2 id="Demo1-链表的插入排序"><a href="#Demo1-链表的插入排序" class="headerlink" title="Demo1(链表的插入排序)"></a>Demo1(链表的插入排序)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode *insertionSortList(ListNode *head) &#123;</div><div class="line">        ListNode *sortedHead = new ListNode(-1);</div><div class="line">        <span class="keyword">while</span>(head != NULL)</div><div class="line">        &#123;</div><div class="line">            //保存head位置</div><div class="line">            ListNode *temp = head-&gt;next;</div><div class="line">            ListNode *cur = sortedHead;</div><div class="line">            <span class="keyword">while</span>(cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val &lt; head-&gt;val)</div><div class="line">            &#123;</div><div class="line">                cur = cur-&gt;next;</div><div class="line">            &#125;</div><div class="line">            //插入</div><div class="line">            head-&gt;next = cur-&gt;next;</div><div class="line">            cur-&gt;next = head;</div><div class="line">            //恢复head</div><div class="line">            head = temp;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> sortedHead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>本题是插入排序的链表版本。</p>
<p>传统数组版本做法就是两重循环，第一重是遍历所有元素，第二重是遍历已排序部分进行插入。</p>
<p>链表版本类似，在遍历每个元素过程中，遍历已排序部分进行插入。</p>
]]></content>
      
        
        <tags>
            
            <tag> 插入排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode148. Sort List]]></title>
      <url>/2017/11/26/LeetCode148/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="external">Description</a></h1><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<h2 id="Demo1-用的分治法加递归"><a href="#Demo1-用的分治法加递归" class="headerlink" title="Demo1(用的分治法加递归)"></a>Demo1(用的分治法加递归)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;  </div><div class="line">public:  </div><div class="line">    ListNode *sortList(ListNode *head) &#123;  </div><div class="line">        <span class="keyword">if</span> (head == NULL || head-&gt;next == NULL) <span class="built_in">return</span> head;  </div><div class="line">        ListNode* slower = head; //slower是左1/2链表的尾巴  </div><div class="line">        ListNode* slow = head-&gt;next;//slow是右1/2链表的开始  </div><div class="line">        ListNode* fast = head-&gt;next-&gt;next;//fast每次走2步，slow每次走1步，当fast走到原链表结尾的时候，slow就走到了1/2点了。  </div><div class="line">        <span class="keyword">while</span>(fast != NULL) &#123;  </div><div class="line">            slower = slow;  </div><div class="line">            fast = fast-&gt;next;  </div><div class="line">            slow = slow-&gt;next;  </div><div class="line">            <span class="keyword">if</span>(fast != NULL) fast = fast-&gt;next;  </div><div class="line">        &#125;  </div><div class="line">//        slower = slow; //测试后发现，如果把slow或者slower向右移动一位，可能会造成infinite loop，所以还是应该保持slow就在原链表1/2处的位置。  </div><div class="line">//        slow = slow-&gt;next; //如果使用这个错误版本的代码，&#123;4,3,8,7,2,1,9,5,6,0&#125; 这个例子会有infinite loop。</div><div class="line">        slower-&gt;next = NULL;  </div><div class="line">        ListNode* left = sortList(head);  </div><div class="line">        ListNode* right = sortList(slow);  </div><div class="line">        ListNode* dummy_head = new ListNode(-1); //避免讨论head是不是空。  </div><div class="line">        ListNode* tail = dummy_head;  </div><div class="line">        <span class="keyword">while</span>(left!= NULL &amp;&amp; right != NULL) &#123;  </div><div class="line">            <span class="keyword">if</span> (left-&gt;val &lt; right-&gt;val) &#123;  </div><div class="line">                tail-&gt;next = left;  </div><div class="line">                left = left-&gt;next;  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                tail-&gt;next = right;  </div><div class="line">                right = right-&gt;next;  </div><div class="line">            &#125;  </div><div class="line">            tail = tail-&gt;next;  </div><div class="line">            tail-&gt;next = NULL;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">while</span> (left != NULL) &#123;  </div><div class="line">            tail-&gt;next = left;  </div><div class="line">            left = left-&gt;next;  </div><div class="line">            tail = tail-&gt;next;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">while</span> (right != NULL) &#123;  </div><div class="line">            tail-&gt;next = right;  </div><div class="line">            right = right-&gt;next;  </div><div class="line">            tail = tail-&gt;next;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        ListNode* return_head = dummy_head-&gt;next;  </div><div class="line">        delete dummy_head;  </div><div class="line">        dummy_head = NULL;  </div><div class="line">        <span class="built_in">return</span> return_head;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：<br>挺有意思的一道题目。表面上看，能够有O(n lgn)时间复杂度的算法为，快速排序，堆排序，归并排序，三者的空间复杂度分别为O(1), O(N),O(N)<br>所以一开始，我想着用快速排序的方法来解决，但是发现代码很难写出来。于是网上看了一下提示，发现其实方法选错了。应该使用的方法是归并排序。<br>通常而言，也就是针对数组而言，归并排序的空间复杂度为O(N), 你需要开出O(N)的额外空间来容纳数组，来表示归并后的顺序。但是，对于链表而言，<br>你可以省下这部分空间的开销，你只需要改变节点的next指针的指向，就可以表示新的归并后的顺序了，所以空间复杂度陡然降到了O(1)。</p>
]]></content>
      
        
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode150. Evaluate Reverse Polish Notation]]></title>
      <url>/2017/11/25/LeetCode150/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/" target="_blank" rel="external">Description</a></h1><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"2"</span>, <span class="string">"1"</span>, <span class="string">"+"</span>, <span class="string">"3"</span>, <span class="string">"*"</span>] -&gt; ((2 + 1) * 3) -&gt; 9</div></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">"4"</span>, <span class="string">"13"</span>, <span class="string">"5"</span>, <span class="string">"/"</span>, <span class="string">"+"</span>] -&gt; (4 + (13 / 5)) -&gt; 6</div></pre></td></tr></table></figure>
<h2 id="Demo1-用的栈"><a href="#Demo1-用的栈" class="headerlink" title="Demo1(用的栈)"></a>Demo1(用的栈)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</div><div class="line">        stack&lt;int&gt;s;</div><div class="line">        int l,r;</div><div class="line">        <span class="keyword">for</span>(int i=0;i&lt;tokens.size();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">"+"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l+r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">"-"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l-r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">"*"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l*r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">"/"</span>)</div><div class="line">            &#123;</div><div class="line">                r=s.top();</div><div class="line">                s.pop();</div><div class="line">                l=s.top();</div><div class="line">                s.pop();</div><div class="line">                s.push(l/r);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                s.push(atoi((tokens[i]).c_str()));//由字符串转化成数字</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> s.top();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>思路：从左到右遍历表达式的每个数字和字符，遇到数字就进栈，遇到符号，就将栈顶的两个数字取出（注意第一次取出的是右操作数，<br>第二次取出的栈顶数字是左操作数），进行运算，将运算结果压栈，一直到最终获得计算结果（最终的栈顶数字）。</p>
]]></content>
      
        
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode441. Arranging Coins]]></title>
      <url>/2017/11/20/LeetCode441/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/arranging-coins/description/" target="_blank" rel="external">Description</a></h1><p>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.</p>
<p>Given n, find the total number of full staircase rows that can be formed.</p>
<p>n is a non-negative integer and fits within the range of a 32-bit signed integer.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">n = 5</div><div class="line"></div><div class="line">The coins can form the following rows:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">Because the 3rd row is incomplete, we <span class="built_in">return</span> 2.</div></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n = 8</div><div class="line"></div><div class="line">The coins can form the following rows:</div><div class="line">¤</div><div class="line">¤ ¤</div><div class="line">¤ ¤ ¤</div><div class="line">¤ ¤</div><div class="line"></div><div class="line">Because the 4th row is incomplete, we <span class="built_in">return</span> 3.</div></pre></td></tr></table></figure>
<h2 id="Demo1-用的二分搜索"><a href="#Demo1-用的二分搜索" class="headerlink" title="Demo1(用的二分搜索)"></a>Demo1(用的二分搜索)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int arrangeCoins(int n) &#123;</div><div class="line">        <span class="keyword">if</span> (n &lt;= 1) <span class="built_in">return</span> n;</div><div class="line">        long low = 1, high = n;</div><div class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">            long mid = low + (high - low) / 2;</div><div class="line">            <span class="keyword">if</span> (mid * (mid + 1) / 2 &lt;= n) low = mid + 1;//把1到mid的和和n相比，缩小mid的范围</div><div class="line">            <span class="keyword">else</span> high = mid;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> low - 1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>复杂度为O(lgn)的方法，用到了二分搜索法，我们搜索前i行之和刚好大于n的临界点，<br>这样我们减一个就是能排满的行数，注意我们计算前i行之和有可能会整型溢出，所以<br>我们需要将变量都定义成长整型</p>
]]></content>
      
        
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-287. Find the Duplicate Number]]></title>
      <url>/2017/11/15/LeetCode287/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="external">Description</a></h1><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>
<h2 id="Demo-二分法"><a href="#Demo-二分法" class="headerlink" title="Demo(二分法)"></a>Demo(二分法)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int min=1;</div><div class="line">        int max=nums.size() - 1;//nums.size()</div><div class="line">        int mid;</div><div class="line">        <span class="keyword">while</span>(min&lt;max)</div><div class="line">        &#123;</div><div class="line">            int cnt=0; //cnt为不大于中位数的数字个数</div><div class="line">            mid=(min+max)/2;//用加法求中位数比用减法好</div><div class="line">            <span class="keyword">for</span>(int i=0;i&lt;nums.size();i++)//这里注意不是有序数组，所以不能随着每次范围的变小减小数组个数的搜索</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums[i]&lt;=mid)</div><div class="line">                    cnt++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cnt&gt;mid)</div><div class="line">            &#123;</div><div class="line">                max=mid;    //如果不大于mid的数字个数比mid多的话，则重复数字应该出现在[low, mid]之间</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                min=mid+1; //如果不大于mid的数字个数比mid少的话，说明重复的数字出现在后半段中[mid+1，high]</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> min;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-230. Kth Smallest Element in a BST]]></title>
      <url>/2017/11/13/LeetCode230/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="external">Description</a></h1><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<h2 id="Demo-二叉搜索"><a href="#Demo-二叉搜索" class="headerlink" title="Demo(二叉搜索)"></a>Demo(二叉搜索)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition <span class="keyword">for</span> a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int calcLeftsize(TreeNode*root)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(root==NULL)</div><div class="line">            <span class="built_in">return</span> 0;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="built_in">return</span> (1+calcLeftsize(root-&gt;left)+calcLeftsize(root-&gt;right));</div><div class="line">    &#125;</div><div class="line">    int kthSmallest(TreeNode* root, int k) &#123;</div><div class="line">        <span class="keyword">if</span>(!root)</div><div class="line">            <span class="built_in">return</span> 0;</div><div class="line">        int leftSize=calcLeftsize(root-&gt;left);//这里很重要，是计算root-&gt;left的大小</div><div class="line">        <span class="keyword">if</span>(leftSize==k-1)</div><div class="line">            <span class="built_in">return</span> root-&gt;val;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftSize&gt;=k)</div><div class="line">            <span class="built_in">return</span> kthSmallest(root-&gt;left,k);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">return</span> kthSmallest(root-&gt;right,k-leftSize-1);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//在二叉搜索树种，找到第K个元素。<br>算法如下：<br>1、计算左子树元素个数left。<br>2、 left+1 = K，则根节点即为第K个元素<br>      left &gt;=k, 则第K个元素在左子树中，<br>     left +1 &lt;k, 则转换为在右子树中，寻找第K-left-1元素。</p>
]]></content>
      
        
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-167. Two Sum II - Input array is sorted]]></title>
      <url>/2017/11/13/LeetCode167/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="external">Description</a></h1><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: numbers=&#123;2, 7, 11, 15&#125;, target=9</div><div class="line">Output: index1=1, index2=2</div></pre></td></tr></table></figure>
<h2 id="Demo-二叉搜索"><a href="#Demo-二叉搜索" class="headerlink" title="Demo(二叉搜索)"></a>Demo(二叉搜索)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</div><div class="line">        int low=0;</div><div class="line">        int high=numbers.size()-1;</div><div class="line">        <span class="keyword">while</span>(numbers[low]+numbers[high]!=target)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(numbers[low]+numbers[high]&lt;target)</div><div class="line">                low++;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                high--;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> vector&lt;int&gt;(&#123;low+1,high+1&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-695. Max Area of Island]]></title>
      <url>/2017/11/06/LeetCode695/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="external">Description</a></h1><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</div><div class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</div><div class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</div><div class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</div><div class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</div><div class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</div><div class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</div><div class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</div><div class="line">Given the above grid, <span class="built_in">return</span> 6. Note the answer is not 11, because the island must be connected 4-directionally.</div></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[0,0,0,0,0,0,0,0]]</div><div class="line">Given the above grid, <span class="built_in">return</span> 0.</div><div class="line">Note: The length of each dimension <span class="keyword">in</span> the given grid does not exceed 50.</div></pre></td></tr></table></figure>
<h2 id="Demo1-用的dfs"><a href="#Demo1-用的dfs" class="headerlink" title="Demo1(用的dfs)"></a>Demo1(用的dfs)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</div><div class="line">        int m,n,area=0;</div><div class="line">        m=grid.size();n=grid[0].size();</div><div class="line">        <span class="keyword">for</span>(int i=0;i&lt;m;i++)</div><div class="line">            <span class="keyword">for</span>(int j=0;j&lt;n;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j]==1)</div><div class="line">                    area=max(area,dfs(grid,i,j));</div><div class="line">            &#125;</div><div class="line">        <span class="built_in">return</span> area;</div><div class="line">    &#125;</div><div class="line">    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp;grid,int row,int col)</div><div class="line">    &#123;</div><div class="line">        int m,n,area=1;</div><div class="line">        int r,c;</div><div class="line">        grid[row][col]=2;</div><div class="line">        vector&lt;int&gt;dir(&#123;-1,0,1,0,-1&#125;);</div><div class="line">        m=grid.size();</div><div class="line">        n=grid[0].size();  </div><div class="line">        <span class="keyword">for</span>(int i=0;i&lt;4;i++)</div><div class="line">        &#123;</div><div class="line">            r=row+dir[i];//这个地方r和row要分开，不然r一直是累加的</div><div class="line">            c=col+dir[i+1];</div><div class="line">            <span class="keyword">if</span>(r&gt;=0&amp;&amp;r&lt;m&amp;&amp;c&gt;=0&amp;&amp;c&lt;n&amp;&amp;grid[r][c]==1)</div><div class="line">                area+=dfs(grid,r,c);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> area;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Demo2-用的bfs"><a href="#Demo2-用的bfs" class="headerlink" title="Demo2(用的bfs)"></a>Demo2(用的bfs)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</div><div class="line">        int m,n,area=0;</div><div class="line">        m=grid.size();n=grid[0].size();</div><div class="line">        <span class="keyword">for</span>(int i=0;i&lt;m;i++)</div><div class="line">            <span class="keyword">for</span>(int j=0;j&lt;n;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(grid[i][j]==1)</div><div class="line">                    area=max(area,bfs(grid,i,j));</div><div class="line">            &#125;</div><div class="line">        <span class="built_in">return</span> area;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int bfs(vector&lt;vector&lt;int&gt;&gt;&amp;grid,int row,int col)</div><div class="line">    &#123;</div><div class="line">        int m,n,area=1;</div><div class="line">        int row1,col1;</div><div class="line">        int r,c;</div><div class="line">        queue&lt;pair&lt;int,int&gt;&gt;myq;</div><div class="line">        myq.push(&#123;row,col&#125;);</div><div class="line">        grid[row][col]=2;</div><div class="line">        vector&lt;int&gt;dir(&#123;-1,0,1,0,-1&#125;);</div><div class="line">        m=grid.size();</div><div class="line">        n=grid[0].size();  </div><div class="line">        <span class="keyword">while</span>(!myq.empty())</div><div class="line">        &#123;</div><div class="line">            row1=myq.front().first;//不是first()</div><div class="line">            col1=myq.front().second;</div><div class="line">            myq.pop();</div><div class="line">            <span class="keyword">for</span>(int i=0;i&lt;4;i++)</div><div class="line">            &#123;</div><div class="line">                r=row1+dir[i];//这个地方r和row要分开，不然r一直是累加的</div><div class="line">                c=col1+dir[i+1];</div><div class="line">                <span class="keyword">if</span>(r&gt;=0&amp;&amp;r&lt;m&amp;&amp;c&gt;=0&amp;&amp;c&lt;n&amp;&amp;grid[r][c]==1)</div><div class="line">                &#123;</div><div class="line">                    area++;</div><div class="line">                    grid[r][c]=2;</div><div class="line">                    myq.push(&#123;r,c&#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;                       </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">return</span> area;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/11/02/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-A series of Combination Sum]]></title>
      <url>/2017/11/02/LeetCode39/</url>
      <content type="html"><![CDATA[<h1 id="39-Combination-Sum-I"><a href="#39-Combination-Sum-I" class="headerlink" title="39.Combination Sum I"></a><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="external">39.Combination Sum I</a></h1><p>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set [2, 3, 6, 7] and target 7, </p>
<h2 id="A-solution-set-is"><a href="#A-solution-set-is" class="headerlink" title="A solution set is:"></a>A solution set is:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [7],</div><div class="line">  [2, 2, 3]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="Demo-用的回溯法"><a href="#Demo-用的回溯法" class="headerlink" title="Demo(用的回溯法)"></a>Demo(用的回溯法)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void search(vector&lt;int&gt;&amp;candidates,int next,vector&lt;int&gt;&amp;tmp,vector&lt;vector&lt;int&gt;&gt;&amp;result,int target)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(target==0)</div><div class="line">        &#123;</div><div class="line">            result.push_back(tmp);</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(next==candidates.size()||target-candidates[next]&lt;0)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        tmp.push_back(candidates[next]);</div><div class="line">        search(candidates,next,tmp,result,target-candidates[next]);</div><div class="line">        tmp.pop_back();</div><div class="line">        search(candidates,next+1,tmp,result,target);</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</div><div class="line">        vector&lt;int&gt;tmp;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt;result;</div><div class="line">        sort(candidates.begin(),candidates.end());//注意这一步</div><div class="line">        search(candidates,0,tmp,result,target);</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="external">40. Combination Sum II</a></h1><p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, </p>
<h2 id="A-solution-set-is-1"><a href="#A-solution-set-is-1" class="headerlink" title="A solution set is:"></a>A solution set is:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1, 7],</div><div class="line">  [1, 2, 5],</div><div class="line">  [2, 6],</div><div class="line">  [1, 1, 6]</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="Demo-用的回溯法-1"><a href="#Demo-用的回溯法-1" class="headerlink" title="Demo(用的回溯法)"></a>Demo(用的回溯法)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void search(vector&lt;int&gt;&amp;candidates,int next,vector&lt;int&gt;&amp;tmp,vector&lt;vector&lt;int&gt;&gt;&amp;result,int target)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(target==0)</div><div class="line">        &#123;</div><div class="line">            result.push_back(tmp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(int i=next;i&lt;candidates.size();i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(candidates[i]&gt;target)</div><div class="line">                    <span class="built_in">return</span>;</div><div class="line">                <span class="keyword">if</span>(i&amp;&amp;candidates[i]==candidates[i-1]&amp;&amp;i&gt;next)</div><div class="line">                    <span class="built_in">continue</span>;</div><div class="line">                tmp.push_back(candidates[i]);</div><div class="line">                search(candidates,i+1,tmp,result,target-candidates[i]);</div><div class="line">                tmp.pop_back();</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</div><div class="line">        vector&lt;int&gt;tmp;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt;result;</div><div class="line">        sort(candidates.begin(),candidates.end());//注意这一步</div><div class="line">        search(candidates,0,tmp,result,target);</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;   </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a href="https://leetcode.com/problems/combination-sum-iii/description/" target="_blank" rel="external">216. Combination Sum III</a></h1><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: k = 3, n = 7</div><div class="line"></div><div class="line">Output:</div><div class="line"></div><div class="line">[[1,2,4]]</div></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input: k = 3, n = 9</div><div class="line"></div><div class="line">Output:</div><div class="line"></div><div class="line">[[1,2,6], [1,3,5], [2,3,4]]</div></pre></td></tr></table></figure>
<h2 id="Demo-用的回溯法-2"><a href="#Demo-用的回溯法-2" class="headerlink" title="Demo(用的回溯法)"></a>Demo(用的回溯法)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void search(vector&lt;int&gt;&amp;tmp,vector&lt;vector&lt;int&gt;&gt;&amp;res,int next,int j,int k,int target)//j是tmp数组存进去的个数</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(target==0&amp;&amp;j==k)</div><div class="line">        &#123;</div><div class="line">            res.push_back(tmp);</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(target==0||j&gt;k||next&gt;=10||target-next&lt;0)</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        tmp.push_back(next);</div><div class="line">        search(tmp,res,next+1,j+1,k,target-next);</div><div class="line">        tmp.pop_back();</div><div class="line">        search(tmp,res,next+1,j,k,target);</div><div class="line">    &#125;</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</div><div class="line">        vector&lt;int&gt;tmp;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt;res;</div><div class="line">        search(tmp,res,1,0,k,n);</div><div class="line">        <span class="built_in">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>//感觉这个题一直是在搜索下个元素满足条件吗，不满足的话return，跳过这个元素判断下个元素，<br>//满足的话先存在数组里再判断下一个元素,自己做的,开心</p>
<h1 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377.Combination Sum IV"></a><a href="https://leetcode.com/problems/combination-sum-iv/description/" target="_blank" rel="external">377.Combination Sum IV</a></h1><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">nums = [1, 2, 3]</div><div class="line">target = 4</div><div class="line"></div><div class="line">The possible combination ways are:</div><div class="line">(1, 1, 1, 1)</div><div class="line">(1, 1, 2)</div><div class="line">(1, 2, 1)</div><div class="line">(1, 3)</div><div class="line">(2, 1, 1)</div><div class="line">(2, 2)</div><div class="line">(3, 1)</div><div class="line"></div><div class="line">Note that different sequences are counted as different combinations.</div><div class="line"></div><div class="line">Therefore the output is 7.</div></pre></td></tr></table></figure>
<h2 id="Demo-用的动态规划"><a href="#Demo-用的动态规划" class="headerlink" title="Demo(用的动态规划)"></a>Demo(用的动态规划)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        vector&lt;int&gt;dp(target+1,0);</div><div class="line">        dp[0]=1;</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        int i;</div><div class="line">        <span class="keyword">for</span>(i=1;i&lt;=target;i++)</div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">for</span>(int a:nums)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(i&lt;a)</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">                dp[i]+=dp[i<span class="_">-a</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> dp[i-1];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 回溯法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-392. Is Subsequence]]></title>
      <url>/2017/10/31/LeetCode392/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="external">Description</a></h1><p>Given a string s and a string t, check if s is subsequence of t.</p>
<p>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not).</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">"abc"</span>, t = <span class="string">"ahbgdc"</span></div><div class="line"></div><div class="line">Return <span class="literal">true</span>.</div></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">"axc"</span>, t = <span class="string">"ahbgdc"</span></div><div class="line"></div><div class="line">Return <span class="literal">false</span>.</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isSubsequence(string s, string t) &#123;</div><div class="line">        int m,n;</div><div class="line">        m=s.length();</div><div class="line">        n=t.length();</div><div class="line">        int i=0,j=0;</div><div class="line">        <span class="keyword">for</span>(;i&lt;m&amp;&amp;j&lt;n;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i]==t[j])</div><div class="line">            &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;         </div><div class="line">        <span class="built_in">return</span> (i==m);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-413. Arithmetic Slices]]></title>
      <url>/2017/10/26/LeetCode413/</url>
      <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="external">Description</a></h1><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<p>For example, these are arithmetic sequence:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1, 3, 5, 7, 9</div><div class="line">7, 7, 7, 7</div><div class="line">3, -1, -5, -9</div></pre></td></tr></table></figure></p>
<p>The following sequence is not arithmetic.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1, 1, 2, 5, 7</div></pre></td></tr></table></figure></p>
<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>
<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>
<p>The function should return the number of arithmetic slices in the array A.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = [1, 2, 3, 4]</div><div class="line"></div><div class="line"><span class="built_in">return</span>: 3, <span class="keyword">for</span> 3 arithmetic slices <span class="keyword">in</span> A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;</div><div class="line">        int n=A.size();</div><div class="line">        vector&lt;int&gt;dp(n,0);</div><div class="line">        <span class="keyword">if</span>(n&lt;3)</div><div class="line">            <span class="built_in">return</span> 0;</div><div class="line">        int result=0;</div><div class="line">        <span class="keyword">for</span>(int i=2;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>((A[i]-A[i-1])==(A[i-1]-A[i-2]))</div><div class="line">                dp[i]=dp[i-1]+1;//以第i个数结尾增加了几个Arithmetic Slices</div><div class="line">            result+=dp[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
  
  
</search>
