<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2018%2F02%2F05%2FLeetCode106%2F</url>
    <content type="text"><![CDATA[DescriptionGiven inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. Example123456789inorder = [9,3,15,20,7]postorder = [9,15,7,20,3]Return the following binary tree: 3 / \ 9 20 / \ 15 7 Demo(递归)12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return buildTRee(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1); &#125; TreeNode* buildTRee(vector&lt;int&gt;&amp; inorder,int iLeft,int iRight,vector&lt;int&gt;&amp; postorder,int pLeft,int pRight) &#123; if(iLeft&gt;iRight||pLeft&gt;pRight) return NULL; int i; TreeNode*cur=new TreeNode(postorder[pRight]); for(i=iLeft;i&lt;=iRight;i++) if(inorder[i]==cur-&gt;val) break; cur-&gt;left=buildTRee(inorder,iLeft,i-1,postorder,pLeft,pLeft+i-iLeft-1); cur-&gt;right=buildTRee(inorder,i+1,iRight,postorder,pLeft+i-iLeft,pRight-1); return cur; &#125;&#125;; //思路：iLeft、iRight是inorder中最左和最右起始点，pLeft、pRight是postorder中最左和最右起始点，i - iLeft 是计算inorder中根节点位置和左边起始点的距离。这个题首先找规律，后序数组中最后一个元素肯定是总的根节点，由此去中序数组中可以找到这个根节点的左子树和右子树，中序中找到的左子树个数也是后序中从起始点算起同样个数是左子树，左子树和右子树看成完整的树以同样的方式递归。]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode109. Convert Sorted List to Binary Search Tree]]></title>
    <url>%2F2018%2F01%2F26%2FLeetCode109%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 Demo(递归)123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* currentHead=NULL; TreeNode* buildTree(int start,int end)&#123; if(start&gt;end) return NULL; int mid=start+(end-start)/2; TreeNode* left=buildTree(start,mid-1); TreeNode* root=new TreeNode(currentHead-&gt;val); root-&gt;left=left; currentHead=currentHead-&gt;next; TreeNode* right=buildTree(mid+1,end); root-&gt;right=right; return root; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; if(head==NULL) return NULL; currentHead=head; int len=0; while(head!=NULL) &#123; head=head-&gt;next; len++; &#125; return buildTree(0,len-1); &#125;&#125;; //思路：看到一种自底向上的方法，算法复杂度为O(N)。先递归构建左子树，在构建左子树的同时不断移动链表的头指针，链表的头指针永远是对应当前子树位置的。一直到左叶子节点，左叶子节点对应的就是链表的第一个元素，生成左叶子节点之后移动链表当前指针。ps:这道题也挺难，得多看看]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[snakeGame]]></title>
    <url>%2F2018%2F01%2F16%2FsnakeGame%2F</url>
    <content type="text"><![CDATA[这是一个贪吃蛇游戏点击进入]]></content>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode123. Best Time to Buy and Sell Stock III]]></title>
    <url>%2F2018%2F01%2F10%2FLeetCode123%2F</url>
    <content type="text"><![CDATA[DescriptionSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Demo(局部最优和全局最优)123456789101112131415161718192021class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n=prices.size(); if(n==0) return 0; vector&lt;vector&lt;int&gt;&gt; local(n, vector&lt;int&gt;(3, 0)); vector&lt;vector&lt;int&gt;&gt; global(n, vector&lt;int&gt;(3, 0)); for(int i=1;i&lt;n;i++)//第一天局部收益和全局收益都为0,所以从第二天算起 &#123; int diff=prices[i]-prices[i-1]; for(int j=1;j&lt;=2;j++) &#123; local[i][j]=max(global[i-1][j-1]+max(0,diff),local[i-1][j]+diff);//max中最后一个参数是+diff，因为local是今天卖出最后一笔股票 global[i][j]=max(global[i-1][j],local[i][j]); &#125; &#125; return global[n-1][2]; &#125;&#125;; //思路：这里我们需要两个递推公式来分别更新两个变量local和global，我们其实可以求至少k次交易的最大利润，找到通解后可以设定 k = 2，即为本题的解答。我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为：local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)global[i][j] = max(local[i][j], global[i - 1][j])其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值中取较大值，而全局最优比较局部最优和前一天的全局最优。ps:这道题其实挺难的，同时用到了局部最优和全局最优]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode125. Valid Palindrome]]></title>
    <url>%2F2017%2F12%2F31%2FLeetCode125%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Example12"A man, a plan, a canal: Panama" is a palindrome."race a car" is not a palindrome. Demo12345678910111213class Solution &#123;public: bool isPalindrome(string s) &#123; for(int i=0,j=s.size()-1;i&lt;j;i++,j--) &#123; while(!isalnum(s[i])&amp;&amp;i&lt;j)i++; while(!isalnum(s[j])&amp;&amp;i&lt;j)j--; if(toupper(s[i])!=toupper(s[j]))//判断不区分大小写字母是否相等的方法 return false; &#125; return true; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode129. Sum Root to Leaf Numbers]]></title>
    <url>%2F2017%2F12%2F29%2FLeetCode129%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Example1234567 1 / \ 2 3The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Return the sum = 12 + 13 = 25. Demo(递归)123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; return dfs(root,0); &#125; int dfs(TreeNode*root,int sum) &#123; if(root==NULL) return 0; sum=sum*10+root-&gt;val; if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) return sum; return dfs(root-&gt;left,sum)+dfs(root-&gt;right,sum); &#125;&#125;; //思路：用递归是比较自然的想法，节点可能出现的情况:(1)左孩子或者右孩子两个都为NULL(叶节点)，此时递归返回。(2)左孩子或者右孩子某一个为NULL，此时继续推进下一层调用，只是在下一层中，会发现有一个为NULL节点，走到NULL节点当然应该返回了。(3)左孩子或者右孩子都不为NULL，此时继续推进下一层的调用。虽然(2)和(3)都是继续推进下一层的调用，但是由于(2)会遇到NULL节点，对于这个特殊情况，需要写句话处理一下。ps:递归要想清楚这些问题。(1)要用到什么参数 (2)节点都有哪些情况? (3)递归什么时候返回？]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode132. Palindrome Partitioning II]]></title>
    <url>%2F2017%2F12%2F27%2FLeetCode132%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Example12given s = "aab",Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut. Demo(动态规划)12345678910111213141516171819202122class Solution &#123;public: int minCut(string s) &#123; int n=s.size(); vector&lt;vector&lt;int&gt;&gt;dp(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt;cut(n+1,INT_MAX); cut[n]=0; for(int i=n-1;i&gt;=0;i--) &#123; //cut[i]=INT_MAX; for(int j=i;j&lt;n;j++) &#123; if(s[i]==s[j]&amp;&amp;(j-i&lt;=1||dp[i+1][j-1]==1))//一激动就把大小号写反，-_-|| &#123; dp[i][j]=1; cut[i]=min(cut[j+1]+1,cut[i]); &#125; &#125; &#125; return cut[0]-1; &#125;&#125;; //思路：对于一个字符串，我们需要考虑所有可能的分割，这个问题可以抽象成一个DP问题，对于一个长度为n的字符串，设DP[i][j]表示第i个字符到第j个字符是否构成回文，若是，则DP[i][j]=1;若否，则DP[i][j]=0;如此，根据回文的约束条件（对称性），DP[i][j]构成回文需满足：1、输入字符串s[i]==s[j],对称性；2、条件1满足并不能保证i到j构成回文，还须：（j-i）&lt;=1或者DP[i+1][j-1]=1；即，i、j相邻或者i=j，也就是相邻字符相等构成回文或者字符自身构成回文，如果i、j不相邻或者相等，i到j构成回文的前提就是DP[i+1][j-1]=1.cut[i]表示第i个字符到最后一个字符所构成的子串的最小分割次数，这里的i有约束条件，就是第i个位置必须是可进行回文分割的，即DP[i][j]==1 (j&gt;=i&amp;&amp;j&lt;s.length())]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode131. Palindrome Partitioning]]></title>
    <url>%2F2017%2F12%2F27%2FLeetCode131%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example1234567given s = "aab",Return[ ["aa","b"], ["a","a","b"]] Demo(回溯法)123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt;res; vector&lt;string&gt;path; helper(s,0,res,path); return res; &#125; void helper(string s,int pos,vector&lt;vector&lt;string&gt;&gt;&amp;res,vector&lt;string&gt;&amp;path) &#123; if(pos==s.size()) &#123; res.push_back(path); return; &#125; for(int i=pos;i&lt;s.size();i++) &#123; if(isPalindrome(s.substr(pos,i-pos+1))) &#123; path.push_back(s.substr(pos,i-pos+1)); helper(s,i+1,res,path); path.pop_back(); &#125; &#125; &#125; bool isPalindrome(string s) &#123; int start=0; int end=s.size()-1; while(start&lt;end) &#123; if(s[start++]!=s[end--])//注意是end-- &#123; return false; &#125; &#125; return true; &#125;&#125;; //思路：于是感觉对于一个字符串，可以对这个字符串进行遍历，如果前pos个字符串本身是个回文字符，那么只需要求解后面的子字符的回文串即可，于是这个问题被分解成了一个更小的问题。这道题更像一个分治法的题，将问题规模不断缩小，当然的遍历字符串的过程中需要进行回溯。除了需要一个进行递归的辅助函数外，还需要定义一个判断一个字符串是否是回文字符串的辅助函数，程序的逻辑非常简单。这种回溯法题不会多总结，多找规律啊]]></content>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode133. Clone Graph]]></title>
    <url>%2F2017%2F12%2F18%2FLeetCode133%2F</url>
    <content type="text"><![CDATA[DescriptionClone an undirected graph. Each node in the graph contains a label and a list of its neighbors. OJ’s undirected graph serialization:Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #. First node is labeled as 0. Connect node 0 to both nodes 1 and 2.Second node is labeled as 1. Connect node 1 to node 2.Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle. Example1234567Visually, the graph looks like the following: 1 / \ / \ 0 --- 2 / \ \_/ Demo1(bfs)1234567891011121314151617181920212223242526272829303132333435/** * Definition for undirected graph. * struct UndirectedGraphNode &#123; * int label; * vector&lt;UndirectedGraphNode *&gt; neighbors; * UndirectedGraphNode(int x) : label(x) &#123;&#125;; * &#125;; */class Solution &#123;public: UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123; if(node==NULL) return NULL; unordered_map&lt;UndirectedGraphNode*,UndirectedGraphNode*&gt;hash; hash[node]=new UndirectedGraphNode(node-&gt;label);//这个语句既创建了新节点，又将新节点的引用(hash[node])和原节点(node)用hash一一对应起来 queue&lt;UndirectedGraphNode*&gt;que; que.push(node); while(!que.empty()) &#123; UndirectedGraphNode*curNode=que.front(); que.pop(); for(auto neigh:curNode-&gt;neighbors)//以后也可以这样用 &#123; if(hash.find(neigh)==hash.end())//如果其某个邻居没被创建，才创建一个，并将这个邻居加入到遍历的队伍 &#123; hash[neigh]=new UndirectedGraphNode(neigh-&gt;label); que.push(neigh); &#125; hash[curNode]-&gt;neighbors.push_back(hash[neigh]);//不管这个邻居有没有被创建，都是我这个节点的邻居，都需要加入到我的邻居数组里 &#125; &#125; return hash[node]; &#125;&#125;; Demo2(dfs)12345678910111213141516171819202122/** * Definition for undirected graph. * struct UndirectedGraphNode &#123; * int label; * vector&lt;UndirectedGraphNode *&gt; neighbors; * UndirectedGraphNode(int x) : label(x) &#123;&#125;; * &#125;; */class Solution &#123;public: unordered_map&lt;UndirectedGraphNode*,UndirectedGraphNode*&gt;hash; UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123; if(node==NULL) return node; if(hash.count(node)) return hash[node]; hash[node]=new UndirectedGraphNode(node-&gt;label); for(auto neigh:node-&gt;neighbors) hash[node]-&gt;neighbors.push_back(cloneGraph(neigh)); return hash[node]; &#125;&#125;; //思路：克隆图的一个难点就是一个结点的邻居可能在已经出现过，这样你只要把他的指针加到邻居集合中即可，也有可能这个结点还没出现过，因此你需要新建一个这个结点，因此我们需要一个hash表来对结点做一一映射．本题有两种方法来做，广度搜索BFS和深度搜索DFS. 广度搜索BFS利用队列，每次遍历队列头结点所有的邻居，如果其某个邻居还没有被创建，那就创建一个，并且将其加入到队列中去．否则说明这个结点已经被创建，而我们只在一个结点刚被创建时才将其加入到队列中去，因此这个结点已经被创建我们就没必要将其入队列了．每次遍历完之后就克隆好了一个结点和其邻居．然后直到队列为空，我们就完成了克隆的操作． ２．深度搜索DFSDFS利用递归一般可以写出比BFS更优雅整洁的代码．每次搜索的时候看这个结点是不是已经被创建，是的话就返回其copy，否则就创建，然后再依次深度遍历其邻居结点并将其加入邻居集合中去．ps:凭我刷了这么多bfs和dfs题的经验，我感觉bfs就是用队列，dfs就是用递归٩(๑❛ᴗ❛๑)۶]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode134. Gas Station]]></title>
    <url>%2F2017%2F12%2F18%2FLeetCode134%2F</url>
    <content type="text"><![CDATA[DescriptionThere are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1. Note:The solution is guaranteed to be unique. Demo(用了一个数学定理)12345678910111213141516int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start = 0; // 起始位置 int remain = 0; // 当前剩余燃料 int debt = 0; // 前面没能走完的路上欠的债 for (int i = 0; i &lt; gas.size(); i++) &#123; remain += gas[i] - cost[i]; if (remain &lt; 0) &#123; debt += remain; start = i + 1; remain = 0; &#125; &#125; return remain + debt &gt;= 0 ? start : -1;&#125; //思路：非常经典的一道题。可以转换成求最大连续和做，但是有更简单的方法。基于一个数学定理： 如果一个数组的总和非负，那么一定可以找到一个起始位置，从他开始绕数组一圈，累加和一直都是非负的有了这个定理，判断到底是否存在这样的解非常容易，只需要把全部的油耗情况计算出来看看是否大于等于0即可。 那么如何求开始位置在哪？ 注意到这样一个现象： 假如从位置i开始，i+1，i+2…，一路开过来一路油箱都没有空。说明什么？说明从i到i+1，i+2，…肯定是正积累。 现在突然发现开往位置j时油箱空了。这说明什么？说明从位置i开始没法走完全程(废话)。那么，我们要从位置i+1开始重新尝试吗？不需要！为什么？因为前面已经知道，位置i肯定是正积累，那么，如果从位置i+1开始走更加没法走完全程了，因为没有位置i的正积累了。同理，也不用从i+2，i+3，…开始尝试。所以我们可以放心地从位置j+1开始尝试。]]></content>
      <tags>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode137. Single Number II]]></title>
    <url>%2F2017%2F12%2F17%2FLeetCode137%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Demo(按位与或)1234567891011121314151617181920class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int length=nums.size(); int result=0; for(int i=0;i&lt;32;i++) &#123; int count=0; int mask=1&lt;&lt;i;//设置某一位为一，方便后面的按位与或操作 for(int j=0;j&lt;length;j++) &#123; if(nums[j]&amp;mask) count++; &#125; if(count%3) result|=mask; &#125; return result; &#125;&#125;; //思路：考虑每个元素的为一个32位的二进制数，这样每一位上出现要么为1，要么为0。对数组，统计每一位上1 出现的次数count，必定是3N或者3N+1 次。让count对3取模，能够获得到那个只出现1次的元素该位是0还是1。]]></content>
      <tags>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode138. Copy List with Random Pointer]]></title>
    <url>%2F2017%2F12%2F17%2FLeetCode138%2F</url>
    <content type="text"><![CDATA[DescriptionA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Demo1(使用hash_map)1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return NULL; unordered_map&lt;RandomListNode*, RandomListNode*&gt; mp; // 创建一个新的链表头 RandomListNode *new_head = new RandomListNode(head-&gt;label); // node1负责指向原链表，node2负责指向新链表 RandomListNode *node1 = head, *node2 = new_head; /** * 按照原链表的结构不断创建新的节点，并维护好next指针，将node1与node2的对应关系保存到hash_map中， * 以备后面维护random指针的时候，可以通过node1找到对应的node2。 */ while (node1-&gt;next != NULL) &#123; mp[node1] = node2; node1 = node1-&gt;next; node2-&gt;next = new RandomListNode(node1-&gt;label); node2 = node2-&gt;next; &#125; // 将两个链表的尾巴的对应关系也保存好 mp[node1] = node2; // 继续从头开始处理random指针 node1 = head; node2 = new_head; while (node1!= NULL) &#123; node2-&gt;random = mp[node1-&gt;random];//node2-&gt;random指向新链表的某个节点，不是原始链表的节点 node1 = node1-&gt;next; node2 = node2-&gt;next; &#125; return new_head; &#125;&#125;; Demo2(不使用hash_map)12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; /** * 假设：l1代表原链表中的节点；l2代表新链表中的节点 */ RandomListNode *new_head, *l1, *l2; if (head == NULL) return NULL; /** * 第一步：在每一个l1后面创建一个l2，并让l1指向l2，l2指向下一个l1； */ for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; l2 = new RandomListNode(l1-&gt;label); l2-&gt;next = l1-&gt;next; l1-&gt;next = l2; &#125; /** * 第二步：给l2的random赋值，l1的random的next指向的就是l2的random的目标； */ new_head = head-&gt;next; for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; if (l1-&gt;random != NULL) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next; &#125; /** * 第三步：需要将整个链表拆成两个链表，具体做法是让l1的next指向后面的后面； * l2的next也指向后面的后面。 */ for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;next; l1-&gt;next = l2-&gt;next; if (l2-&gt;next != NULL) l2-&gt;next = l2-&gt;next-&gt;next;//需要判断l2-&gt;next！=NULL,因为如果是NULL的话,NULL没有next,会报错 &#125; return new_head; &#125;&#125;; //思路：在代码中已标明]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode139. Word Break 140. Word Break II]]></title>
    <url>%2F2017%2F12%2F09%2FLeetCode139%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. UPDATE (2017/1/4):The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. Example12345givens = "leetcode",dict = ["leet", "code"].Return true because "leetcode" can be segmented as "leet code". Demo(动态规划)123456789101112131415class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int len=s.size(); vector&lt;bool&gt;dp(len+1,false); dp[0]=true; for(int i=1;i&lt;=len;i++) for(int j=0;j&lt;i;j++) &#123; if(dp[j]&amp;&amp;find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end())//注意vector&lt;string&gt;的find方法 dp[i]=true; &#125; return dp[len]; &#125;&#125;; DescriptionGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words. Return all such possible sentences.UPDATE (2017/1/4):The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. Example123456givens = "catsanddog",dict = ["cat", "cats", "and", "sand", "dog"].A solution is ["cats and dog", "cat sand dog"].Return true because "leetcode" can be segmented as "leet code". Demo(dp+dfs)12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: void buildPaths(vector&lt;bool&gt;&amp;isBreakable,string s,unordered_set&lt;string&gt;&amp;wordSet,int pos,string cur,vector&lt;string&gt;&amp;res,int maxlen,int minlen) &#123; int i,len=s.size(); for(i=minlen;i&lt;=min(maxlen,len-pos);i++) &#123; if(isBreakable[i+pos]&amp;&amp;wordSet.count(s.substr(pos,i))) if(pos+i==len) res.push_back(cur+s.substr(pos,i)); else buildPaths(isBreakable,s,wordSet,pos+i,cur+s.substr(pos,i)+" ",res,maxlen,minlen); &#125; &#125; vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); int size=s.size(),maxlen=INT_MIN,minlen=INT_MAX; int i,len; vector&lt;bool&gt;isBreakable((size+1),false); vector&lt;string&gt;res; for(string word:wordSet) &#123; maxlen=max(maxlen,(int)word.length()); minlen=min(minlen,(int)word.length()); &#125; for(i=size-minlen,isBreakable[size]=true;i&gt;=0;i--) for(len=minlen;len&lt;=min(maxlen,size-i);len++) &#123; if(isBreakable[i+len]&amp;&amp;wordSet.count(s.substr(i,len))) &#123; isBreakable[i]=true; break; &#125; &#125; if(isBreakable[0]) buildPaths(isBreakable,s,wordSet,0,"",res,maxlen,minlen); return res; &#125;&#125;; //思路：The basic idea is to use DP to create an array isBreakable[i] to indicate whether s[i..sSize-1] is breakable.Then we can use such information to help us speed up the DFS path build process (buildPath). Learned from other posts,I first calculated minlen and maxlen to speed up the process.（有点难这个题，摘自LeetCode）]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode141. Linked List Cycle 142. Linked List Cycle II]]></title>
    <url>%2F2017%2F12%2F08%2FLeetCode141%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? Demo(快慢指针)123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL||head-&gt;next==NULL) return false; ListNode*slow=head,*fast=head; while((fast-&gt;next!=NULL)&amp;&amp;(fast-&gt;next-&gt;next!=NULL))//如果有环肯定不指向空，如果指向空肯定不成环 &#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) return true; &#125; return false; &#125;&#125;; 思路：使用快慢指针。如果链表有环，则两指针必在某一时刻相等。 DescriptionGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up:Can you solve it without using extra space? Demo(快慢指针)12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL||head-&gt;next==NULL) return NULL; ListNode*slow=head,*fast=head; while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)//如果有环肯定不指向空，如果指向空肯定不成环 &#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) break; &#125; if(fast==slow&amp;&amp;fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) &#123; slow=head; while(slow!=fast) &#123; slow=slow-&gt;next; fast=fast-&gt;next; &#125; return slow; &#125; return NULL; &#125;&#125;; 思路：如图所示，设链表头是X，环的第一个节点是Y，slow和fast第一次的交点是Z。各段的长度分别是a,b,c。第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b。因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b，可以得到a=c（这个结论很重要！）。我们已经得到了结论a=c，那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇！也就是环的第一个节点。]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode143. Reorder List]]></title>
    <url>%2F2017%2F12%2F05%2FLeetCode143%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You must do this in-place without altering the nodes’ values. Example1Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;. Demo1(链表)123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return; //第一步，先使用快慢指针将链表从中间分割成两段 ListNode*slow=head,*fast=head,*p=head,*q=head; while(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL) &#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; fast=slow-&gt;next,slow-&gt;next=NULL; //第二步，后半段就地逆置 p=fast,q=fast-&gt;next,fast-&gt;next=NULL;//注意fast-&gt;next=NULL,有它p就是独立的一个链表了，q的元素不断加到p上，最后p是完整的后半段。 while(q) &#123; ListNode*tmp=q-&gt;next; q-&gt;next=p; p=q; q=tmp; &#125; //第三步，后半段插入到前半段中 q=head; while(p&amp;&amp;q) &#123; ListNode*tmp1=q-&gt;next,*tmp2=p-&gt;next; p-&gt;next=q-&gt;next; q-&gt;next=p; q=tmp1; p=tmp2; &#125; &#125;&#125;; 思路：先使用快慢指针将链表从中间分割成两段，然后后半段就地逆置．之后合并插入到前半段链表即可，时间复杂度O(n)。这三步已经在代码中标注，每个步骤可灵活运用于别的题目。]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode147. Insertion Sort List]]></title>
    <url>%2F2017%2F12%2F05%2FLeetCode147%2F</url>
    <content type="text"><![CDATA[DescriptionSort a linked list using insertion sort. Demo1(链表的插入排序)123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *insertionSortList(ListNode *head) &#123; ListNode *sortedHead = new ListNode(-1); while(head != NULL) &#123; //保存head位置 ListNode *temp = head-&gt;next; ListNode *cur = sortedHead; while(cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val &lt; head-&gt;val) &#123; cur = cur-&gt;next; &#125; //插入 head-&gt;next = cur-&gt;next; cur-&gt;next = head; //恢复head head = temp; &#125; return sortedHead-&gt;next; &#125;&#125;; 思路：本题是插入排序的链表版本。 传统数组版本做法就是两重循环，第一重是遍历所有元素，第二重是遍历已排序部分进行插入。 链表版本类似，在遍历每个元素过程中，遍历已排序部分进行插入。]]></content>
      <tags>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode148. Sort List]]></title>
    <url>%2F2017%2F11%2F26%2FLeetCode148%2F</url>
    <content type="text"><![CDATA[DescriptionSort a linked list in O(n log n) time using constant space complexity. Demo1(用的分治法加递归)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public: ListNode *sortList(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) return head; ListNode* slower = head; //slower是左1/2链表的尾巴 ListNode* slow = head-&gt;next;//slow是右1/2链表的开始 ListNode* fast = head-&gt;next-&gt;next;//fast每次走2步，slow每次走1步，当fast走到原链表结尾的时候，slow就走到了1/2点了。 while(fast != NULL) &#123; slower = slow; fast = fast-&gt;next; slow = slow-&gt;next; if(fast != NULL) fast = fast-&gt;next; &#125; // slower = slow; //测试后发现，如果把slow或者slower向右移动一位，可能会造成infinite loop，所以还是应该保持slow就在原链表1/2处的位置。 // slow = slow-&gt;next; //如果使用这个错误版本的代码，&#123;4,3,8,7,2,1,9,5,6,0&#125; 这个例子会有infinite loop。 slower-&gt;next = NULL; ListNode* left = sortList(head); ListNode* right = sortList(slow); ListNode* dummy_head = new ListNode(-1); //避免讨论head是不是空。 ListNode* tail = dummy_head; while(left!= NULL &amp;&amp; right != NULL) &#123; if (left-&gt;val &lt; right-&gt;val) &#123; tail-&gt;next = left; left = left-&gt;next; &#125; else &#123; tail-&gt;next = right; right = right-&gt;next; &#125; tail = tail-&gt;next; tail-&gt;next = NULL; &#125; while (left != NULL) &#123; tail-&gt;next = left; left = left-&gt;next; tail = tail-&gt;next; &#125; while (right != NULL) &#123; tail-&gt;next = right; right = right-&gt;next; tail = tail-&gt;next; &#125; ListNode* return_head = dummy_head-&gt;next; delete dummy_head; dummy_head = NULL; return return_head; &#125; &#125;; 思路：挺有意思的一道题目。表面上看，能够有O(n lgn)时间复杂度的算法为，快速排序，堆排序，归并排序，三者的空间复杂度分别为O(1), O(N),O(N)所以一开始，我想着用快速排序的方法来解决，但是发现代码很难写出来。于是网上看了一下提示，发现其实方法选错了。应该使用的方法是归并排序。通常而言，也就是针对数组而言，归并排序的空间复杂度为O(N), 你需要开出O(N)的额外空间来容纳数组，来表示归并后的顺序。但是，对于链表而言，你可以省下这部分空间的开销，你只需要改变节点的next指针的指向，就可以表示新的归并后的顺序了，所以空间复杂度陡然降到了O(1)。]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode150. Evaluate Reverse Polish Notation]]></title>
    <url>%2F2017%2F11%2F25%2FLeetCode150%2F</url>
    <content type="text"><![CDATA[DescriptionEvaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Example 1:1["2", "1", "+", "3", "*"] -&gt; ((2 + 1) * 3) -&gt; 9 Example 2:1["4", "13", "5", "/", "+"] -&gt; (4 + (13 / 5)) -&gt; 6 Demo1(用的栈)12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt;s; int l,r; for(int i=0;i&lt;tokens.size();i++) &#123; if(tokens[i]=="+") &#123; r=s.top(); s.pop(); l=s.top(); s.pop(); s.push(l+r); &#125; else if(tokens[i]=="-") &#123; r=s.top(); s.pop(); l=s.top(); s.pop(); s.push(l-r); &#125; else if(tokens[i]=="*") &#123; r=s.top(); s.pop(); l=s.top(); s.pop(); s.push(l*r); &#125; else if(tokens[i]=="/") &#123; r=s.top(); s.pop(); l=s.top(); s.pop(); s.push(l/r); &#125; else&#123; s.push(atoi((tokens[i]).c_str()));//由字符串转化成数字 &#125; &#125; return s.top(); &#125;&#125;; 思路：从左到右遍历表达式的每个数字和字符，遇到数字就进栈，遇到符号，就将栈顶的两个数字取出（注意第一次取出的是右操作数，第二次取出的栈顶数字是左操作数），进行运算，将运算结果压栈，一直到最终获得计算结果（最终的栈顶数字）。]]></content>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode441. Arranging Coins]]></title>
    <url>%2F2017%2F11%2F20%2FLeetCode441%2F</url>
    <content type="text"><![CDATA[DescriptionYou have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1:12345678n = 5The coins can form the following rows:¤¤ ¤¤ ¤Because the 3rd row is incomplete, we return 2. Example 2:123456789n = 8The coins can form the following rows:¤¤ ¤¤ ¤ ¤¤ ¤Because the 4th row is incomplete, we return 3. Demo1(用的二分搜索)12345678910111213class Solution &#123;public: int arrangeCoins(int n) &#123; if (n &lt;= 1) return n; long low = 1, high = n; while (low &lt; high) &#123; long mid = low + (high - low) / 2; if (mid * (mid + 1) / 2 &lt;= n) low = mid + 1;//把1到mid的和和n相比，缩小mid的范围 else high = mid; &#125; return low - 1; &#125;&#125;; 复杂度为O(lgn)的方法，用到了二分搜索法，我们搜索前i行之和刚好大于n的临界点，这样我们减一个就是能排满的行数，注意我们计算前i行之和有可能会整型溢出，所以我们需要将变量都定义成长整型]]></content>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-287. Find the Duplicate Number]]></title>
    <url>%2F2017%2F11%2F15%2FLeetCode287%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note:You must not modify the array (assume the array is read only).You must use only constant, O(1) extra space.Your runtime complexity should be less than O(n2).There is only one duplicate number in the array, but it could be repeated more than once. Demo(二分法)12345678910111213141516171819202122232425class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int min=1; int max=nums.size() - 1;//nums.size() int mid; while(min&lt;max) &#123; int cnt=0; //cnt为不大于中位数的数字个数 mid=(min+max)/2;//用加法求中位数比用减法好 for(int i=0;i&lt;nums.size();i++)//这里注意不是有序数组，所以不能随着每次范围的变小减小数组个数的搜索 &#123; if(nums[i]&lt;=mid) cnt++; &#125; if(cnt&gt;mid) &#123; max=mid; //如果不大于mid的数字个数比mid多的话，则重复数字应该出现在[low, mid]之间 &#125; else min=mid+1; //如果不大于mid的数字个数比mid少的话，说明重复的数字出现在后半段中[mid+1，high] &#125; return min; &#125;&#125;;]]></content>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-230. Kth Smallest Element in a BST]]></title>
    <url>%2F2017%2F11%2F13%2FLeetCode230%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Demo(二叉搜索)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int calcLeftsize(TreeNode*root) &#123; if(root==NULL) return 0; else return (1+calcLeftsize(root-&gt;left)+calcLeftsize(root-&gt;right)); &#125; int kthSmallest(TreeNode* root, int k) &#123; if(!root) return 0; int leftSize=calcLeftsize(root-&gt;left);//这里很重要，是计算root-&gt;left的大小 if(leftSize==k-1) return root-&gt;val; else if(leftSize&gt;=k) return kthSmallest(root-&gt;left,k); else return kthSmallest(root-&gt;right,k-leftSize-1); &#125;&#125;;&#125;; //在二叉搜索树种，找到第K个元素。算法如下：1、计算左子树元素个数left。2、 left+1 = K，则根节点即为第K个元素 left &gt;=k, 则第K个元素在左子树中， left +1 &lt;k, 则转换为在右子树中，寻找第K-left-1元素。]]></content>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-167. Two Sum II - Input array is sorted]]></title>
    <url>%2F2017%2F11%2F13%2FLeetCode167%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example12Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 Demo(二叉搜索)123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int low=0; int high=numbers.size()-1; while(numbers[low]+numbers[high]!=target) &#123; if(numbers[low]+numbers[high]&lt;target) low++; else high--; &#125; return vector&lt;int&gt;(&#123;low+1,high+1&#125;); &#125;&#125;;]]></content>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-695. Max Area of Island]]></title>
    <url>%2F2017%2F11%2F06%2FLeetCode695%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1:123456789[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. Example 2:123[[0,0,0,0,0,0,0,0]]Given the above grid, return 0.Note: The length of each dimension in the given grid does not exceed 50. Demo1(用的dfs)12345678910111213141516171819202122232425262728293031class Solution &#123;public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m,n,area=0; m=grid.size();n=grid[0].size(); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) &#123; if(grid[i][j]==1) area=max(area,dfs(grid,i,j)); &#125; return area; &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp;grid,int row,int col) &#123; int m,n,area=1; int r,c; grid[row][col]=2; vector&lt;int&gt;dir(&#123;-1,0,1,0,-1&#125;); m=grid.size(); n=grid[0].size(); for(int i=0;i&lt;4;i++) &#123; r=row+dir[i];//这个地方r和row要分开，不然r一直是累加的 c=col+dir[i+1]; if(r&gt;=0&amp;&amp;r&lt;m&amp;&amp;c&gt;=0&amp;&amp;c&lt;n&amp;&amp;grid[r][c]==1) area+=dfs(grid,r,c); &#125; return area; &#125;&#125;; Demo2(用的bfs)12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m,n,area=0; m=grid.size();n=grid[0].size(); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) &#123; if(grid[i][j]==1) area=max(area,bfs(grid,i,j)); &#125; return area; &#125; int bfs(vector&lt;vector&lt;int&gt;&gt;&amp;grid,int row,int col) &#123; int m,n,area=1; int row1,col1; int r,c; queue&lt;pair&lt;int,int&gt;&gt;myq; myq.push(&#123;row,col&#125;); grid[row][col]=2; vector&lt;int&gt;dir(&#123;-1,0,1,0,-1&#125;); m=grid.size(); n=grid[0].size(); while(!myq.empty()) &#123; row1=myq.front().first;//不是first() col1=myq.front().second; myq.pop(); for(int i=0;i&lt;4;i++) &#123; r=row1+dir[i];//这个地方r和row要分开，不然r一直是累加的 c=col1+dir[i+1]; if(r&gt;=0&amp;&amp;r&lt;m&amp;&amp;c&gt;=0&amp;&amp;c&lt;n&amp;&amp;grid[r][c]==1) &#123; area++; grid[r][c]=2; myq.push(&#123;r,c&#125;); &#125; &#125; &#125; return area; &#125;&#125;;]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-A series of Combination Sum]]></title>
    <url>%2F2017%2F11%2F02%2FLeetCode39%2F</url>
    <content type="text"><![CDATA[39.Combination Sum IGiven a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is:1234[ [7], [2, 2, 3]] Demo(用的回溯法)123456789101112131415161718192021222324class Solution &#123;public: void search(vector&lt;int&gt;&amp;candidates,int next,vector&lt;int&gt;&amp;tmp,vector&lt;vector&lt;int&gt;&gt;&amp;result,int target) &#123; if(target==0) &#123; result.push_back(tmp); return; &#125; if(next==candidates.size()||target-candidates[next]&lt;0) return; tmp.push_back(candidates[next]); search(candidates,next,tmp,result,target-candidates[next]); tmp.pop_back(); search(candidates,next+1,tmp,result,target); &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;int&gt;tmp; vector&lt;vector&lt;int&gt;&gt;result; sort(candidates.begin(),candidates.end());//注意这一步 search(candidates,0,tmp,result,target); return result; &#125;&#125;; 40. Combination Sum IIGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is:123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Demo(用的回溯法)12345678910111213141516171819202122232425262728293031class Solution &#123;public: void search(vector&lt;int&gt;&amp;candidates,int next,vector&lt;int&gt;&amp;tmp,vector&lt;vector&lt;int&gt;&gt;&amp;result,int target) &#123; if(target==0) &#123; result.push_back(tmp); &#125; else &#123; for(int i=next;i&lt;candidates.size();i++) &#123; if(candidates[i]&gt;target) return; if(i&amp;&amp;candidates[i]==candidates[i-1]&amp;&amp;i&gt;next) continue; tmp.push_back(candidates[i]); search(candidates,i+1,tmp,result,target-candidates[i]); tmp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;int&gt;tmp; vector&lt;vector&lt;int&gt;&gt;result; sort(candidates.begin(),candidates.end());//注意这一步 search(candidates,0,tmp,result,target); return result; &#125; &#125;; 216. Combination Sum IIIFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1:12345Input: k = 3, n = 7Output:[[1,2,4]] Example 2:12345Input: k = 3, n = 9Output:[[1,2,6], [1,3,5], [2,3,4]] Demo(用的回溯法)1234567891011121314151617181920212223class Solution &#123;public: void search(vector&lt;int&gt;&amp;tmp,vector&lt;vector&lt;int&gt;&gt;&amp;res,int next,int j,int k,int target)//j是tmp数组存进去的个数 &#123; if(target==0&amp;&amp;j==k) &#123; res.push_back(tmp); return; &#125; if(target==0||j&gt;k||next&gt;=10||target-next&lt;0) return; tmp.push_back(next); search(tmp,res,next+1,j+1,k,target-next); tmp.pop_back(); search(tmp,res,next+1,j,k,target); &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;int&gt;tmp; vector&lt;vector&lt;int&gt;&gt;res; search(tmp,res,1,0,k,n); return res; &#125;&#125;; //感觉这个题一直是在搜索下个元素满足条件吗，不满足的话return，跳过这个元素判断下个元素，//满足的话先存在数组里再判断下一个元素,自己做的,开心 377.Combination Sum IVGiven an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example:123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Demo(用的动态规划)12345678910111213141516171819class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt;dp(target+1,0); dp[0]=1; sort(nums.begin(),nums.end()); int i; for(i=1;i&lt;=target;i++) &#123; for(int a:nums) &#123; if(i&lt;a) break; dp[i]+=dp[i-a]; &#125; &#125; return dp[i-1]; &#125;&#125;;]]></content>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-392. Is Subsequence]]></title>
    <url>%2F2017%2F10%2F31%2FLeetCode392%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not). Example 1123s = "abc", t = "ahbgdc"Return true. Example 2123s = "axc", t = "ahbgdc"Return false. Demo1234567891011121314151617class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int m,n; m=s.length(); n=t.length(); int i=0,j=0; for(;i&lt;m&amp;&amp;j&lt;n;j++) &#123; if(s[i]==t[j]) &#123; i++; &#125; &#125; return (i==m); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-413. Arithmetic Slices]]></title>
    <url>%2F2017%2F10%2F26%2FLeetCode413%2F</url>
    <content type="text"><![CDATA[DescriptionA sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence:1231, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9 The following sequence is not arithmetic.11, 1, 2, 5, 7 A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N. A slice (P, Q) of array A is called arithmetic if the sequence:A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q. The function should return the number of arithmetic slices in the array A. Example123A = [1, 2, 3, 4]return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. Demo1234567891011121314151617class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int n=A.size(); vector&lt;int&gt;dp(n,0); if(n&lt;3) return 0; int result=0; for(int i=2;i&lt;n;i++) &#123; if((A[i]-A[i-1])==(A[i-1]-A[i-2])) dp[i]=dp[i-1]+1;//以第i个数结尾增加了几个Arithmetic Slices result+=dp[i]; &#125; return result; &#125;&#125;;]]></content>
  </entry>
</search>
